<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[网络安全法]]></title>
    <url>%2F2019%2F01%2F06%2F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[听说不懂法的人是没法搞安全的，所以有空还是认真看一看（认真脸）。 目录 第一章 总则 第二章 网络安全支持与促进 第三章 网络运行安全 第一节 一般规定 第二节 关键信息基础设施的运行安全 第四章 网络信息安全 第五章 监测预警与应急处置 第六章 法律责任 第七章 附 则 条文 第一章 总 则 第一条 为了保障网络安全，维护网络空间主权和国家安全、社会公共利益，保护公民、法人和其他组织的合法权益，促进经济社会信息化健康发展，制定本法。 第二条 在中华人民共和国境内建设、运营、维护和使用网络，以及网络安全的监督管理，适用本法。 第三条 国家坚持网络安全与信息化发展并重，遵循积极利用、科学发展、依法管理、确保安全的方针，推进网络基础设施建设和互联互通，鼓励网络技术创新和应用，支持培养网络安全人才，建立健全网络安全保障体系，提高网络安全保护能力。 第四条 国家制定并不断完善网络安全战略，明确保障网络安全的基本要求和主要目标，提出重点领域的网络安全政策、工作任务和措施。 第五条 国家采取措施，监测、防御、处置来源于中华人民共和国境内外的网络安全风险和威胁，保护关键信息基础设施免受攻击、侵入、干扰和破坏，依法惩治网络违法犯罪活动，维护网络空间安全和秩序。 第六条 国家倡导诚实守信、健康文明的网络行为，推动传播社会主义核心价值观，采取措施提高全社会的网络安全意识和水平，形成全社会共同参与促进网络安全的良好环境。 第七条 国家积极开展网络空间治理、网络技术研发和标准制定、打击网络违法犯罪等方面的国际交流与合作，推动构建和平、安全、开放、合作的网络空间，建立多边、民主、透明的网络治理体系。 第八条 国家网信部门负责统筹协调网络安全工作和相关监督管理工作。国务院电信主管部门、公安部门和其他有关机关依照本法和有关法律、行政法规的规定，在各自职责范围内负责网络安全保护和监督管理工作。 县级以上地方人民政府有关部门的网络安全保护和监督管理职责，按照国家有关规定确定。 第九条 网络运营者开展经营和服务活动，必须遵守法律、行政法规，尊重社会公德，遵守商业道德，诚实信用，履行网络安全保护义务，接受政府和社会的监督，承担社会责任。 第十条 建设、运营网络或者通过网络提供服务，应当依照法律、行政法规的规定和国家标准的强制性要求，采取技术措施和其他必要措施，保障网络安全、稳定运行，有效应对网络安全事件，防范网络违法犯罪活动，维护网络数据的完整性、保密性和可用性。 第十一条 网络相关行业组织按照章程，加强行业自律，制定网络安全行为规范，指导会员加强网络安全保护，提高网络安全保护水平，促进行业健康发展。 第十二条 国家保护公民、法人和其他组织依法使用网络的权利，促进网络接入普及，提升网络服务水平，为社会提供安全、便利的网络服务，保障网络信息依法有序自由流动。 任何个人和组织使用网络应当遵守宪法法律，遵守公共秩序，尊重社会公德，不得危害网络安全，不得利用网络从事危害国家安全、荣誉和利益，煽动颠覆国家政权、推翻社会主义制度，煽动分裂国家、破坏国家统一，宣扬恐怖主义、极端主义，宣扬民族仇恨、民族歧视，传播暴力、淫秽色情信息，编造、传播虚假信息扰乱经济秩序和社会秩序，以及侵害他人名誉、隐私、知识产权和其他合法权益等活动。 第十三条 国家支持研究开发有利于未成年人健康成长的网络产品和服务，依法惩治利用网络从事危害未成年人身心健康的活动，为未成年人提供安全、健康的网络环境。 第十四条 任何个人和组织有权对危害网络安全的行为向网信、电信、公安等部门举报。收到举报的部门应当及时依法作出处理；不属于本部门职责的，应当及时移送有权处理的部门。 有关部门应当对举报人的相关信息予以保密，保护举报人的合法权益。 第二章 网络安全支持与促进 第十五条 国家建立和完善网络安全标准体系。国务院标准化行政主管部门和国务院其他有关部门根据各自的职责，组织制定并适时修订有关网络安全管理以及网络产品、服务和运行安全的国家标准、行业标准。 国家支持企业、研究机构、高等学校、网络相关行业组织参与网络安全国家标准、行业标准的制定。 第十六条 国务院和省、自治区、直辖市人民政府应当统筹规划，加大投入，扶持重点网络安全技术产业和项目，支持网络安全技术的研究开发和应用，推广安全可信的网络产品和服务，保护网络技术知识产权，支持企业、研究机构和高等学校等参与国家网络安全技术创新项目。 第十七条 国家推进网络安全社会化服务体系建设，鼓励有关企业、机构开展网络安全认证、检测和风险评估等安全服务。 第十八条 国家鼓励开发网络数据安全保护和利用技术，促进公共数据资源开放，推动技术创新和经济社会发展。 国家支持创新网络安全管理方式，运用网络新技术，提升网络安全保护水平。 第十九条 各级人民政府及其有关部门应当组织开展经常性的网络安全宣传教育，并指导、督促有关单位做好网络安全宣传教育工作。 大众传播媒介应当有针对性地面向社会进行网络安全宣传教育。 第二十条 国家支持企业和高等学校、职业学校等教育培训机构开展网络安全相关教育与培训，采取多种方式培养网络安全人才，促进网络安全人才交流。 第三章 网络运行安全 第一节 一般规定 第二十一条 国家实行网络安全等级保护制度。网络运营者应当按照网络安全等级保护制度的要求，履行下列安全保护义务，保障网络免受干扰、破坏或者未经授权的访问，防止网络数据泄露或者被窃取、篡改： （一）制定内部安全管理制度和操作规程，确定网络安全负责人，落实网络安全保护责任； （二）采取防范计算机病毒和网络攻击、网络侵入等危害网络安全行为的技术措施； （三）采取监测、记录网络运行状态、网络安全事件的技术措施，并按照规定留存相关的网络日志不少于六个月； （四）采取数据分类、重要数据备份和加密等措施； （五）法律、行政法规规定的其他义务。 第二十二条 网络产品、服务应当符合相关国家标准的强制性要求。网络产品、服务的提供者不得设置恶意程序；发现其网络产品、服务存在安全缺陷、漏洞等风险时，应当立即采取补救措施，按照规定及时告知用户并向有关主管部门报告。 网络产品、服务的提供者应当为其产品、服务持续提供安全维护；在规定或者当事人约定的期限内，不得终止提供安全维护。 网络产品、服务具有收集用户信息功能的，其提供者应当向用户明示并取得同意；涉及用户个人信息的，还应当遵守本法和有关法律、行政法规关于个人信息保护的规定。 第二十三条 网络关键设备和网络安全专用产品应当按照相关国家标准的强制性要求，由具备资格的机构安全认证合格或者安全检测符合要求后，方可销售或者提供。国家网信部门会同国务院有关部门制定、公布网络关键设备和网络安全专用产品目录，并推动安全认证和安全检测结果互认，避免重复认证、检测。 第二十四条 网络运营者为用户办理网络接入、域名注册服务，办理固定电话、移动电话等入网手续，或者为用户提供信息发布、即时通讯等服务，在与用户签订协议或者确认提供服务时，应当要求用户提供真实身份信息。用户不提供真实身份信息的，网络运营者不得为其提供相关服务。 国家实施网络可信身份战略，支持研究开发安全、方便的电子身份认证技术，推动不同电子身份认证之间的互认。 第二十五条 网络运营者应当制定网络安全事件应急预案，及时处置系统漏洞、计算机病毒、网络攻击、网络侵入等安全风险；在发生危害网络安全的事件时，立即启动应急预案，采取相应的补救措施，并按照规定向有关主管部门报告。 第二十六条 开展网络安全认证、检测、风险评估等活动，向社会发布系统漏洞、计算机病毒、网络攻击、网络侵入等网络安全信息，应当遵守国家有关规定。 第二十七条 任何个人和组织不得从事非法侵入他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动；不得提供专门用于从事侵入网络、干扰网络正常功能及防护措施、窃取网络数据等危害网络安全活动的程序、工具；明知他人从事危害网络安全的活动的，不得为其提供技术支持、广告推广、支付结算等帮助。 第二十八条 网络运营者应当为公安机关、国家安全机关依法维护国家安全和侦查犯罪的活动提供技术支持和协助。 第二十九条 国家支持网络运营者之间在网络安全信息收集、分析、通报和应急处置等方面进行合作，提高网络运营者的安全保障能力。 有关行业组织建立健全本行业的网络安全保护规范和协作机制，加强对网络安全风险的分析评估，定期向会员进行风险警示，支持、协助会员应对网络安全风险。 第三十条 网信部门和有关部门在履行网络安全保护职责中获取的信息，只能用于维护网络安全的需要，不得用于其他用途。 第二节 关键信息基础设施的运行安全 第三十一条 国家对公共通信和信息服务、能源、交通、水利、金融、公共服务、电子政务等重要行业和领域，以及其他一旦遭到破坏、丧失功能或者数据泄露，可能严重危害国家安全、国计民生、公共利益的关键信息基础设施，在网络安全等级保护制度的基础上，实行重点保护。关键信息基础设施的具体范围和安全保护办法由国务院制定。 国家鼓励关键信息基础设施以外的网络运营者自愿参与关键信息基础设施保护体系。 第三十二条 按照国务院规定的职责分工，负责关键信息基础设施安全保护工作的部门分别编制并组织实施本行业、本领域的关键信息基础设施安全规划，指导和监督关键信息基础设施运行安全保护工作。 第三十三条 建设关键信息基础设施应当确保其具有支持业务稳定、持续运行的性能，并保证安全技术措施同步规划、同步建设、同步使用。 第三十四条 除本法第二十一条的规定外，关键信息基础设施的运营者还应当履行下列安全保护义务： （一）设置专门安全管理机构和安全管理负责人，并对该负责人和关键岗位的人员进行安全背景审查； （二）定期对从业人员进行网络安全教育、技术培训和技能考核； （三）对重要系统和数据库进行容灾备份； （四）制定网络安全事件应急预案，并定期进行演练； （五）法律、行政法规规定的其他义务。 第三十五条 关键信息基础设施的运营者采购网络产品和服务，可能影响国家安全的，应当通过国家网信部门会同国务院有关部门组织的国家安全审查。 第三十六条 关键信息基础设施的运营者采购网络产品和服务，应当按照规定与提供者签订安全保密协议，明确安全和保密义务与责任。 第三十七条 关键信息基础设施的运营者在中华人民共和国境内运营中收集和产生的个人信息和重要数据应当在境内存储。因业务需要，确需向境外提供的，应当按照国家网信部门会同国务院有关部门制定的办法进行安全评估；法律、行政法规另有规定的，依照其规定。 第三十八条 关键信息基础设施的运营者应当自行或者委托网络安全服务机构对其网络的安全性和可能存在的风险每年至少进行一次检测评估，并将检测评估情况和改进措施报送相关负责关键信息基础设施安全保护工作的部门。 第三十九条 国家网信部门应当统筹协调有关部门对关键信息基础设施的安全保护采取下列措施： （一）对关键信息基础设施的安全风险进行抽查检测，提出改进措施，必要时可以委托网络安全服务机构对网络存在的安全风险进行检测评估； （二）定期组织关键信息基础设施的运营者进行网络安全应急演练，提高应对网络安全事件的水平和协同配合能力； （三）促进有关部门、关键信息基础设施的运营者以及有关研究机构、网络安全服务机构等之间的网络安全信息共享； （四）对网络安全事件的应急处置与网络功能的恢复等，提供技术支持和协助。 第四章 网络信息安全 第四十条 网络运营者应当对其收集的用户信息严格保密，并建立健全用户信息保护制度。 第四十一条 网络运营者收集、使用个人信息，应当遵循合法、正当、必要的原则，公开收集、使用规则，明示收集、使用信息的目的、方式和范围，并经被收集者同意。 网络运营者不得收集与其提供的服务无关的个人信息，不得违反法律、行政法规的规定和双方的约定收集、使用个人信息，并应当依照法律、行政法规的规定和与用户的约定，处理其保存的个人信息。 第四十二条 网络运营者不得泄露、篡改、毁损其收集的个人信息；未经被收集者同意，不得向他人提供个人信息。但是，经过处理无法识别特定个人且不能复原的除外。 网络运营者应当采取技术措施和其他必要措施，确保其收集的个人信息安全，防止信息泄露、毁损、丢失。在发生或者可能发生个人信息泄露、毁损、丢失的情况时，应当立即采取补救措施，按照规定及时告知用户并向有关主管部门报告。 第四十三条 个人发现网络运营者违反法律、行政法规的规定或者双方的约定收集、使用其个人信息的，有权要求网络运营者删除其个人信息；发现网络运营者收集、存储的其个人信息有错误的，有权要求网络运营者予以更正。网络运营者应当采取措施予以删除或者更正。 第四十四条 任何个人和组织不得窃取或者以其他非法方式获取个人信息，不得非法出售或者非法向他人提供个人信息。 第四十五条 依法负有网络安全监督管理职责的部门及其工作人员，必须对在履行职责中知悉的个人信息、隐私和商业秘密严格保密，不得泄露、出售或者非法向他人提供。 第四十六条 任何个人和组织应当对其使用网络的行为负责，不得设立用于实施诈骗，传授犯罪方法，制作或者销售违禁物品、管制物品等违法犯罪活动的网站、通讯群组，不得利用网络发布涉及实施诈骗，制作或者销售违禁物品、管制物品以及其他违法犯罪活动的信息。 第四十七条 网络运营者应当加强对其用户发布的信息的管理，发现法律、行政法规禁止发布或者传输的信息的，应当立即停止传输该信息，采取消除等处置措施，防止信息扩散，保存有关记录，并向有关主管部门报告。 第四十八条 任何个人和组织发送的电子信息、提供的应用软件，不得设置恶意程序，不得含有法律、行政法规禁止发布或者传输的信息。 电子信息发送服务提供者和应用软件下载服务提供者，应当履行安全管理义务，知道其用户有前款规定行为的，应当停止提供服务，采取消除等处置措施，保存有关记录，并向有关主管部门报告。 第四十九条 网络运营者应当建立网络信息安全投诉、举报制度，公布投诉、举报方式等信息，及时受理并处理有关网络信息安全的投诉和举报。 网络运营者对网信部门和有关部门依法实施的监督检查，应当予以配合。 第五十条 国家网信部门和有关部门依法履行网络信息安全监督管理职责，发现法律、行政法规禁止发布或者传输的信息的，应当要求网络运营者停止传输，采取消除等处置措施，保存有关记录；对来源于中华人民共和国境外的上述信息，应当通知有关机构采取技术措施和其他必要措施阻断传播。 第五章 监测预警与应急处置 第五十一条 国家建立网络安全监测预警和信息通报制度。国家网信部门应当统筹协调有关部门加强网络安全信息收集、分析和通报工作，按照规定统一发布网络安全监测预警信息。 第五十二条 负责关键信息基础设施安全保护工作的部门，应当建立健全本行业、本领域的网络安全监测预警和信息通报制度，并按照规定报送网络安全监测预警信息。 第五十三条 国家网信部门协调有关部门建立健全网络安全风险评估和应急工作机制，制定网络安全事件应急预案，并定期组织演练。 负责关键信息基础设施安全保护工作的部门应当制定本行业、本领域的网络安全事件应急预案，并定期组织演练。 网络安全事件应急预案应当按照事件发生后的危害程度、影响范围等因素对网络安全事件进行分级，并规定相应的应急处置措施。 第五十四条 网络安全事件发生的风险增大时，省级以上人民政府有关部门应当按照规定的权限和程序，并根据网络安全风险的特点和可能造成的危害，采取下列措施： （一）要求有关部门、机构和人员及时收集、报告有关信息，加强对网络安全风险的监测； （二）组织有关部门、机构和专业人员，对网络安全风险信息进行分析评估，预测事件发生的可能性、影响范围和危害程度； （三）向社会发布网络安全风险预警，发布避免、减轻危害的措施。 第五十五条 发生网络安全事件，应当立即启动网络安全事件应急预案，对网络安全事件进行调查和评估，要求网络运营者采取技术措施和其他必要措施，消除安全隐患，防止危害扩大，并及时向社会发布与公众有关的警示信息。 第五十六条 省级以上人民政府有关部门在履行网络安全监督管理职责中，发现网络存在较大安全风险或者发生安全事件的，可以按照规定的权限和程序对该网络的运营者的法定代表人或者主要负责人进行约谈。网络运营者应当按照要求采取措施，进行整改，消除隐患。 第五十七条 因网络安全事件，发生突发事件或者生产安全事故的，应当依照《中华人民共和国突发事件应对法》、《中华人民共和国安全生产法》等有关法律、行政法规的规定处置。 第五十八条 因维护国家安全和社会公共秩序，处置重大突发社会安全事件的需要，经国务院决定或者批准，可以在特定区域对网络通信采取限制等临时措施。 第六章 法律责任 第五十九条 网络运营者不履行本法第二十一条、第二十五条规定的网络安全保护义务的，由有关主管部门责令改正，给予警告；拒不改正或者导致危害网络安全等后果的，处一万元以上十万元以下罚款，对直接负责的主管人员处五千元以上五万元以下罚款。 关键信息基础设施的运营者不履行本法第三十三条、第三十四条、第三十六条、第三十八条规定的网络安全保护义务的，由有关主管部门责令改正，给予警告；拒不改正或者导致危害网络安全等后果的，处十万元以上一百万元以下罚款，对直接负责的主管人员处一万元以上十万元以下罚款。 第六十条 违反本法第二十二条第一款、第二款和第四十八条第一款规定，有下列行为之一的，由有关主管部门责令改正，给予警告；拒不改正或者导致危害网络安全等后果的，处五万元以上五十万元以下罚款，对直接负责的主管人员处一万元以上十万元以下罚款： （一）设置恶意程序的； （二）对其产品、服务存在的安全缺陷、漏洞等风险未立即采取补救措施，或者未按照规定及时告知用户并向有关主管部门报告的； （三）擅自终止为其产品、服务提供安全维护的。 第六十一条 网络运营者违反本法第二十四条第一款规定，未要求用户提供真实身份信息，或者对不提供真实身份信息的用户提供相关服务的，由有关主管部门责令改正；拒不改正或者情节严重的，处五万元以上五十万元以下罚款，并可以由有关主管部门责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。 第六十二条 违反本法第二十六条规定，开展网络安全认证、检测、风险评估等活动，或者向社会发布系统漏洞、计算机病毒、网络攻击、网络侵入等网络安全信息的，由有关主管部门责令改正，给予警告；拒不改正或者情节严重的，处一万元以上十万元以下罚款，并可以由有关主管部门责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处五千元以上五万元以下罚款。 第六十三条 违反本法第二十七条规定，从事危害网络安全的活动，或者提供专门用于从事危害网络安全活动的程序、工具，或者为他人从事危害网络安全的活动提供技术支持、广告推广、支付结算等帮助，尚不构成犯罪的，由公安机关没收违法所得，处五日以下拘留，可以并处五万元以上五十万元以下罚款；情节较重的，处五日以上十五日以下拘留，可以并处十万元以上一百万元以下罚款。 单位有前款行为的，由公安机关没收违法所得，处十万元以上一百万元以下罚款，并对直接负责的主管人员和其他直接责任人员依照前款规定处罚。 违反本法第二十七条规定，受到治安管理处罚的人员，五年内不得从事网络安全管理和网络运营关键岗位的工作；受到刑事处罚的人员，终身不得从事网络安全管理和网络运营关键岗位的工作。 第六十四条 网络运营者、网络产品或者服务的提供者违反本法第二十二条第三款、第四十一条至第四十三条规定，侵害个人信息依法得到保护的权利的，由有关主管部门责令改正，可以根据情节单处或者并处警告、没收违法所得、处违法所得一倍以上十倍以下罚款，没有违法所得的，处一百万元以下罚款，对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款；情节严重的，并可以责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照。 违反本法第四十四条规定，窃取或者以其他非法方式获取、非法出售或者非法向他人提供个人信息，尚不构成犯罪的，由公安机关没收违法所得，并处违法所得一倍以上十倍以下罚款，没有违法所得的，处一百万元以下罚款。 第六十五条 关键信息基础设施的运营者违反本法第三十五条规定，使用未经安全审查或者安全审查未通过的网络产品或者服务的，由有关主管部门责令停止使用，处采购金额一倍以上十倍以下罚款；对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。 第六十六条 关键信息基础设施的运营者违反本法第三十七条规定，在境外存储网络数据，或者向境外提供网络数据的，由有关主管部门责令改正，给予警告，没收违法所得，处五万元以上五十万元以下罚款，并可以责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照；对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。 第六十七条 违反本法第四十六条规定，设立用于实施违法犯罪活动的网站、通讯群组，或者利用网络发布涉及实施违法犯罪活动的信息，尚不构成犯罪的，由公安机关处五日以下拘留，可以并处一万元以上十万元以下罚款；情节较重的，处五日以上十五日以下拘留，可以并处五万元以上五十万元以下罚款。关闭用于实施违法犯罪活动的网站、通讯群组。 单位有欠款行为的，由公安机关处十万元以上五十万元以下罚款，并对直接负责的主管人员和其他直接责任人员依照前款规定处罚。 第六十八条 网络运营者违反本法第四十七条规定，对法律、行政法规禁止发布或者传输的信息未停止传输、采取消除等处置措施、保存有关记录的，由有关主管部门责令改正，给予警告，没收违法所得；拒不改正或者情节严重的，处十万元以上五十万元以下罚款，并可以责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。 电子信息发送服务提供者、应用软件下载服务提供者，不履行本法第四十八条第二款规定的安全管理义务的，依照前款规定处罚。 第六十九条 网络运营者违反本法规定，有下列行为之一的，由有关主管部门责令改正；拒不改正或者情节严重的，处五万元以上五十万元以下罚款，对直接负责的主管人员和其他直接责任人员，处一万元以上十万元以下罚款： （一）不按照有关部门的要求对法律、行政法规禁止发布或者传输的信息，采取停止传输、消除等处置措施的； （二）拒绝、阻碍有关部门依法实施的监督检查的； （三）拒不向公安机关、国家安全机关提供技术支持和协助的。 第七十条 发布或者传输本法第十二条第二款和其他法律、行政法规禁止发布或者传输的信息的，依照有关法律、行政法规的规定处罚。 第七十一条 有本法规定的违法行为的，依照有关法律、行政法规的规定记入信用档案，并予以公示。 第七十二条 国家机关政务网络的运营者不履行本法规定的网络安全保护义务的，由其上级机关或者有关机关责令改正；对直接负责的主管人员和其他直接责任人员依法给予处分。 第七十三条 网信部门和有关部门违反本法第三十条规定，将在履行网络安全保护职责中获取的信息用于其他用途的，对直接负责的主管人员和其他直接责任人员依法给予处分。 网信部门和有关部门的工作人员玩忽职守、滥用职权、徇私舞弊，尚不构成犯罪的，依法给予处分。 第七十四条 违反本法规定，给他人造成损害的，依法承担民事责任。 违反本法规定，构成违反治安管理行为的，依法给予治安管理处罚；构成犯罪的，依法追究刑事责任。 第七十五条 境外的机构、组织、个人从事攻击、侵入、干扰、破坏等危害中华人民共和国的关键信息基础设施的活动，造成严重后果的，依法追究法律责任；国务院公安部门和有关部门并可以决定对该机构、组织、个人采取冻结财产或者其他必要的制裁措施。 第七章附 则 第七十六条 本法下列用语的含义： （一）网络，是指由计算机或者其他信息终端及相关设备组成的按照一定的规则和程序对信息进行收集、存储、传输、交换、处理的系统。 （二）网络安全，是指通过采取必要措施，防范对网络的攻击、侵入、干扰、破坏和非法使用以及意外事故，使网络处于稳定可靠运行的状态，以及保障网络数据的完整性、保密性、可用性的能力。 （三）网络运营者，是指网络的所有者、管理者和网络服务提供者。 （四）网络数据，是指通过网络收集、存储、传输、处理和产生的各种电子数据。 （五）个人信息，是指以电子或者其他方式记录的能够单独或者与其他信息结合识别自然人个人身份的各种信息，包括但不限于自然人的姓名、出生日期、身份证件号码、个人生物识别信息、住址、电话号码等。 第七十七条 存储、处理涉及国家秘密信息的网络的运行安全保护，除应当遵守本法外，还应当遵守保密法律、行政法规的规定。 第七十八条 军事网络的安全保护，由中央军事委员会另行规定。 第七十九条 本法自2017年6月1日起施行。]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>网络安全法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[波兰式与逆波兰表达式]]></title>
    <url>%2F2019%2F01%2F05%2F%E6%B3%A2%E5%85%B0%E5%BC%8F%E4%B8%8E%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前缀、中缀、后缀表达式(逆波兰表达式)整体介绍 前缀表达式、中缀表达式、后缀表达式都是四则运算的表达方式,用以四则运算表达式求值 ,即数学表达式的求职 一、中缀表达式1.1、简介 中缀表达式就是常见的运算表达式，如(3+4)×5-6 二、前缀表达式2.1、简介 前缀表达式又称波兰式，前缀表达式的运算符位于操作数之前 比如:- × + 3 4 5 6 2.2、如何通过前缀表达式来求值 从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 op 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果 例如:- × + 3 4 5 6 从右至左扫描，将6、5、4、3压入堆栈 遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素，注意与后缀表达式做比较），计算出3+4的值，得7，再将7入栈 接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈 最后是-运算符，计算出35-6的值，即29，由此得出最终结果 2.3、将中缀表达式转换为前缀表达式 转换步骤如下: 初始化两个栈:运算符栈s1，储存中间结果的栈s2 从右至左扫描中缀表达式 遇到操作数时，将其压入s2 遇到运算符时，比较其与s1栈顶运算符的优先级 如果s1为空，或栈顶运算符为右括号“)”，则直接将此运算符入栈 否则，若优先级比栈顶运算符的较高或相等，也将运算符压入s1 否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较 遇到括号时 如果是右括号“)”，则直接压入s1 如果是左括号“(”，则依次弹出S1栈顶的运算符，并压入S2，直到遇到右括号为止，此时将这一对括号丢弃 重复步骤2至5，直到表达式的最左边 将s1中剩余的运算符依次弹出并压入s2 依次弹出s2中的元素并输出，结果即为中缀表达式对应的前缀表达式 例如:1+((2+3)×4)-5具体过程，如下表 结果是:- + 1 × + 2 3 4 5 三、后缀表达式(逆波兰表达式)3.1、简介 后缀表达式又称逆波兰表达式,与前缀表达式相似，只是运算符位于操作数之后 比如:3 4 + 5 × 6 - 3.2、后缀表达式计算机求值 与前缀表达式类似，只是顺序是从左至右： 从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 op 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果 例如后缀表达式“3 4 + 5 × 6 -”： 从左至右扫描，将3和4压入堆栈； 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素，注意与前缀表达式做比较），计算出3+4的值，得7，再将7入栈； 将5入栈； 接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈； 将6入栈； 最后是-运算符，计算出35-6的值，即29，由此得出最终结果。 3.3、将中缀表达式转换为后缀表达式步骤 与转换为前缀表达式相似，步骤如下： 初始化两个栈：运算符栈s1和储存中间结果的栈s2； 从左至右扫描中缀表达式； 遇到操作数时，将其压s2； 遇到运算符时，比较其与s1栈顶运算符的优先级： 如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈； 否则，若优先级比栈顶运算符的高，也将运算符压入s1（注意转换为前缀表达式时是优先级较高或相同，而这里则不包括相同的情况）； 否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较； 遇到括号时： 如果是左括号“(”，则直接压入s1； 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃； 重复步骤2至5，直到表达式的最右边； 将s1中剩余的运算符依次弹出并压入s2； 依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式（转换为前缀表达式时不用逆序） 例如，将中缀表达式“1+((2+3)×4)-5”转换为后缀表达式的过程如下： 因此结果为“1 2 3 + 4 × + 5 -” 3.4、C语言实现中缀表达式变后缀表达式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Node&#123; char ele; struct Node * next;&#125;Node;typedef Node * Stack;Stack MakeStack(void)//新建栈并返回栈顶&#123; Stack S = (Node *)malloc(sizeof(Node)); S-&gt;next = NULL; return S;&#125;void MakeNUll(Stack S)//置空栈&#123; S-&gt;next = NULL;&#125;void Pop(Stack S)//将栈顶弹出&#123; Stack temp = S-&gt;next; S-&gt;next = temp-&gt;next;&#125;void Push(Stack S, char c)//将新节点压入栈&#123; Stack temp = (Node *)malloc(sizeof(Node)); temp-&gt;ele = c; temp-&gt;next = S-&gt;next; S-&gt;next = temp;&#125;Stack FindHead(Stack S)//返回栈顶&#123; Stack temp = S-&gt;next; return temp;&#125;void PrintHead(Stack S)//打印栈顶元素&#123; Stack temp = S-&gt;next; printf(&quot;%c&quot;, temp-&gt;ele);&#125;int main(void)&#123; Stack S = MakeStack(); int i = 0; char str[200]; printf(&quot;Type something.\n&quot;); gets(str); while(str[i] != &apos;\0&apos;) &#123; if(str[i] == &apos;+&apos; || str[i] == &apos;-&apos;)//如果str[i]是加号或减号，则先弹出栈顶直到栈已空或栈顶元素为左括号，再将str[i]压入栈 &#123; if(FindHead(S) == NULL)//若栈已空时，栈顶指针为空，找不到其元素，故须单独讨论 &#123; Push(S, str[i]); &#125; else &#123; while(FindHead(S)-&gt;ele == &apos;+&apos; || FindHead(S)-&gt;ele == &apos;-&apos; || FindHead(S)-&gt;ele == &apos;*&apos; || FindHead(S)-&gt;ele == &apos;/&apos;) &#123; PrintHead(S); Pop(S); &#125; Push(S, str[i]); &#125; &#125; else if(str[i] == &apos;*&apos; || str[i] == &apos;/&apos;)//如果str[i]是乘号或除号，则只有栈顶也是乘除号时才需要弹出 &#123; if(FindHead(S) == NULL) &#123; Push(S, str[i]); &#125; else &#123; while(FindHead(S)-&gt;ele == &apos;*&apos; || FindHead(S)-&gt;ele == &apos;/&apos;) &#123; PrintHead(S); Pop(S); &#125; Push(S, str[i]); &#125; &#125; else if(str[i] == &apos;(&apos;)//如果str[i]是左括号则直接压入栈 &#123; Push(S, str[i]); &#125; else if(str[i] == &apos;)&apos;)//如果str[i]是右括号，则打印并弹出栈中第一个左括号前的所有操作符，最后将此左括号直接弹出 &#123; while(FindHead(S)-&gt;ele != &apos;(&apos;) &#123; PrintHead(S); Pop(S); &#125; Pop(S); &#125; else//如果str[i]不是操作符则直接打印 &#123; printf(&quot;%c&quot;, str[i]); &#125; i++; &#125; while(FindHead(S) != NULL)//遍历后如果栈不为空，则弹出所有操作符 &#123; PrintHead(S); Pop(S); &#125; return 0;&#125; 3.5、C语言实现逆波兰计算器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#define STACK_INIT_SIZE 20#define STACKINCREMENT 10#define MAXBUFFER 10typedef double ElemType;typedef struct&#123; ElemType *base; ElemType *top; int stackSize;&#125;sqStack;// 创建一个栈void InitStack(sqlStack *s)&#123; s-&gt;base = (ElemType *)malloc(STACK_INIT_SIZE *sizeof(ElemType)); if(!s-&gt;base)&#123; exit(0); &#125; s-&gt;top = s-&gt;base; s-&gt;stackSize = STACK_INIT_SIZE;&#125;// 压栈void Push(sqStack *s, ElemType e)&#123; if(s-&gt;top - s-&gt;base &gt;= s-&gt;stackSize)&#123; s-&gt;base = (ElemType *)realloc(s-&gt;base, (s-&gt;stackSize + STACKINCREMENT)*sizeof(ElemType)); if(!s-&gt;base)&#123; exit(0); &#125; &#125; *(s-&gt;top) = e; s-&gt;top++;&#125;void Pop(sqStack *s, ElemType *e)&#123; if(s-&gt;top == s-&gt;base)&#123; return; &#125; *e = *--(s-&gt;top);&#125;// 计算栈的当前容量 int StackLen(sqStack s)&#123; return (s.top - s.base);&#125;double main()&#123; sqStack s; char c; double d, e; char str[MAXBUFFER]; InitStacke(&amp;s); printf(&quot;请按逆波兰表达式输入待计算数据，数据与运算符之间用空格隔开，以#号作为结束标志：\n&quot;); scanf(&quot;%c&quot;, &amp;c); while(C != &apos;#&apos;)&#123; while(isdigit(c) || c==&apos;.&apos;)&#123; // 用于过滤数字 str[i++] = c; str[i] = &apos;\0&apos;; if(i&gt;=10)&#123; printf(&quot;出错：输入的单个数据过大!\n&quot;); return -1; &#125; scanf(&quot;%c&quot;, &amp;c); if(c == &apos; &apos;)&#123; d = atof(str); Push(&amp;s, d); i = 0; break; &#125; &#125; switch(c)&#123; case &apos;+&apos;: Pop(&amp;s, &amp;e); Pop(&amp;s, &amp;d); Push(&amp;s, d+e); break; case &apos;-&apos;: Pop(&amp;s, &amp;e); Pop(&amp;s, &amp;d); Push(&amp;s, d-e); break; case &apos;*&apos;: Pop(&amp;s, &amp;e); Pop(&amp;s, &amp;d); Push(&amp;s, d*e); break; case &apos;/&apos;: Pop(&amp;s, &amp;e); Pop(&amp;s, &amp;d); if(e != 0)&#123; Push(&amp;s, d/e); &#125;else&#123; printf(&quot;\n出错：除数为零!\n&quot;); return -1; &#125; break; &#125; scanf(&quot;%c&quot;, &amp;c); &#125; Pop(&amp;s, &amp;d); printf(&quot;\n最终的计算结果为:%f\n&quot;, d); return 0;&#125;// 计算案例 // 1 2 - 4 5 + * 结果：9.000000// 5 - (6 + 7) * 8 + 9 / 4 5 6 7 + 8 * - 9 4 / + 结果：-96.750000]]></content>
      <categories>
        <category>NUAA那点事</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt环境搭建以及自动打包]]></title>
    <url>%2F2019%2F01%2F02%2FQt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[一、下载安装（Qt是什么就不用我说了 自行百度咯1. 官网下载开始我以为下载qtcreator就是下载了qt,然后发现居然下载qtcreator只是一个空壳，下载qt自带一个qtceator,折腾了老半天，嘤嘤嘤，所以下面地址是直接下载qt的http://download.qt.io/official_releases/qt/我下载的是qt-opensource-windows-x86-5.9.0.exe 2. 安装一路安装下去，此地无账号可以注册一个，为免费的开源版本组件的选择，按需求下，以下是根据《Qt 5.9 C++开发指南》实例下载，这本书还是不错的 3.一些小小的设置设置部分都在Tools-&gt;options，里面有基本上所有的设置包括中文，但是非常不建议中文（你试试就知道了在buiud&amp;run里面可以看到现在的编辑器，当前主要在使用Qt 5.9.0 MinGW 32bit字体风格啥的就自己去瞅瞅就行了 二、编译一个Hello Kitty1. 新建一个项目选择左上角的FIle-&gt;New File or Project这里选择第一个即可然后Kit可以随意选择一个或者多个，会自动检测qt已经具备的Kit,当然全选也可以，反正玩玩而已 2. 项目文件结构总结一下常见文件目录的作用 Headers指定项目中所有的头文件。 FORMS指定UI文件在编译前被uic处理。所有的构建这些UI文件所需的依赖、头文件和源文件都会自动被添加到项目中。 CONFIG指定编译器选项和项目配置，值由qmake内部识别并具有特殊意义。 LIBS指定链接到项目中的库列表。如果使用Unix -l (library) 和 -L (library path) 标志，在Windows上qmake正确处理库（也就是说，将库的完整路径传递给链接器），库必须存在，qmake会寻找-l指定的库所在的目录。 SOURCES指定项目中所有源文件。 3.Designqtcreator具备可视化编辑ui,双击mainwindow.ui即进入左侧任务栏中的Design在左侧拉一个Display Widgets-&gt;Label 进去即可 三、编译以及打包1. 编译，选择Qt 5.9.0 MinGW 32bit(不是强制，可自选)，为了打包所以选择Release点击第二个（非debug,即可编译运行，然后会在源代码的文件夹出现一个build-XX的文件目录找到里面的release-&gt;hello.exe 双击运行会提示少一大堆.dll,所以要打包 2. 自动打包Qt 官方开发环境使用的动态链接库方式，在发布生成的exe程序时，需要复制一大堆 dll，如果自己去复制dll，很可能丢三落四，导致exe在别的电脑里无法正常运行。因此 Qt 官方开发环境里自带了一个工具：windeployqt.exe。这个工具在该编译器所在的bin目录下，是一个终端操作工具你只需要把release目录下的hello.exe复制到bin目录下 cmd输入 windeployqt.exe hello.exe即可，但是这个会导致你的bin目录非常恶心所以直接，新建一个目录，里面放一个从Releasee复制出来的hello.exe,cmd切到hello.exe目录下然后（只要一个hello.exe即可）1&#123;你自己的Qt安装路径&#125;\Qt\5.9\mingw53_32\bin\windeployqt.exe hello.exe 或者先把该编译器的bin目录放在环境变量中1windeployqt.exe hello.exe 然后hello.exe 文件夹下会出现一堆依赖文件，即可帮助你运行hello.exe 3.可能遇到的问题windeployqt.exe的作用其实也就是简单把项目需要的的dll从bin目录下复制出来，所以如果在打包之后运行还提示缺少了什么.dll文件，直接去编译器的bin目录下复制过来即可。]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[prim算法和kruskal算法]]></title>
    <url>%2F2019%2F01%2F01%2Fprim%E7%AE%97%E6%B3%95%E5%92%8Ckruskal%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Prim算法1.概览普里姆算法（Prim算法），图论中的一种算法，可在加权连通图里搜索最小生成树。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点（英语：Vertex (graph theory)），且其所有边的权值之和亦为最小。该算法于1930年由捷克数学家沃伊捷赫·亚尔尼克（英语：Vojtěch Jarník）发现；并在1957年由美国计算机科学家罗伯特·普里姆（英语：Robert C. Prim）独立发现；1959年，艾兹格·迪科斯彻再次发现了该算法。因此，在某些场合，普里姆算法又被称为DJP算法、亚尔尼克算法或普里姆－亚尔尼克算法。 2.算法简单描述1).输入：一个加权连通图，其中顶点集合为V，边集合为E； 2).初始化：Vnew = {x}，其中x为集合V中的任一节点（起始点），Enew = {},为空； 3).重复下列操作，直到Vnew = V： a.在集合E中选取权值最小的边&lt;u, v&gt;，其中u为集合Vnew中的元素，而v不在Vnew集合当中，并且v∈V（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）； b.将v加入集合Vnew中，将&lt;u, v&gt;边加入集合Enew中； 4).输出：使用集合Vnew和Enew来描述所得到的最小生成树。 3.代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;#define INF 10000const int N=6; bool visit[N];int dist[N]=&#123;0,&#125;;int graph[N][N]=&#123;&#123;INF,7,4,INF,INF,INF&#125;, //INF代表两点之间不可达 &#123;7,INF,6,2,INF,4&#125;, &#123;4,6,INF,INF,9,8&#125;, &#123;INF,2,INF,INF,INF,7&#125;, &#123;INF,INF,9,INF,INF,1&#125;, &#123;INF,4,8,7,1,INF&#125;&#125;;int prim(int cur)&#123; int index=cur; cout&lt;&lt;index&lt;&lt;&quot; &quot;; int sum=0; memset(visit,false,sizeof(visit)); visit[cur]=true; for(int i=0;i&lt;N;i++) dist[i]=graph[cur][i];//初始化，每个与a邻接的点的距离存入dist中 for(int i=1;i&lt;N;i++) &#123; int minor=INF; for(int j=0;j&lt;N;j++) &#123; if(!visit[j]&amp;&amp;dist[j]&lt;minor) &#123; minor=dist[j]; index=j; &#125; &#125; visit[index]=true; cout&lt;&lt;index&lt;&lt;&quot; &quot;; sum+=minor; for(int j=0;j&lt;N;j++) &#123; if(!visit[j]&amp;&amp;dist[j]&gt;graph[index][j]) //执行更新，如果点距离当前点的距离更近，就更新dist &#123; dist[j]=graph[index][j]; &#125; &#125; &#125; cout&lt;&lt;endl; return sum; //返回最小生成树的总路径值&#125;int main()&#123; cout&lt;&lt;prim(0)&lt;&lt;endl;&#125; ps(#include &lt;string.h&gt;中定义 void memset( void buffer, int ch, size_t count ); 功能函数拷贝ch 到buffer 从头开始的count 个字符里, 并返回buffer指针。 memset() 可以应用在将一段内存初始化为某个值。例如：1memset( the_array, &apos;\0&apos;, sizeof(the_array) ); 这是将一个数组的所有分量设置成零的很便捷的方法。) Kruskal算法1.概览 排序（按照边的权重，从小到大排序）。 从还没有加入到生成树中所有边中选出最小的边。然后检查加入这条边后，是否会形成环。如果没有形成环，将这条边进入生成树；否则，丢弃它。 重复第 2 步，直到遍历完所有边或者产生了最小生成树。2.算法描述： 选择一种排序算法进行排序。 因为第 1 步我们已经按照边的权重已经从小到大进行排序了，所以我们可以使用一个循环，遍历所有的边。其中，如何检查是否形成环的方法：即新加入的边的两个顶点的 parent 是否相同。3.代码实现123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;struct as&#123; int st,ed,w;//起点，终点，权值 &#125;a[110];int father[110];int findfather(int a)&#123; if(father[a] == a) return a; else return father[a] = findfather(father[a]);&#125;bool cmp(as x,as y)&#123;return x.w &lt; y.w;&#125;int main()&#123; int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m);//n个点m条边 for(int i = 1 ; i &lt;= m ; i++) &#123; scanf(&quot;%d%d%d&quot;,&amp;a[i].st,&amp;a[i].ed,&amp;a[i].w); &#125; for(int i = 1 ; i &lt;= n ; i++) father[i] = i; sort(a+1,a+1+n,cmp); for(int i = 1 ; i &lt;= m ;i++)//并查集避免环的出现 &#123; int fa = findfather(a[i].st); int fb = findfather(a[i].ed); if(fa != fb)//连边不成环则输出 &#123; father[fa] = fb; printf(&quot;边：&quot;); printf(&quot;%d %d %d\n&quot;,a[i].st,a[i].ed,a[i].w); &#125; &#125;&#125; ps(sort第三个参数是比较方式)]]></content>
      <categories>
        <category>NUAA那点事</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSA证明]]></title>
    <url>%2F2018%2F12%2F31%2FRSA%E8%AF%81%E6%98%8E%2F</url>
    <content type="text"><![CDATA[一、RSA介绍RSA 加密算法是一种非对称加密算法。在公开密钥加密和电子商业中 RSA 被广泛使用。RSA 是 1977 年由罗纳德 · 李维斯特（Ron Rivest）、阿迪 · 萨莫尔（Adi Shamir）和伦纳德 · 阿德曼（Leonard Adleman）一起提出的。RSA 就是他们三人姓氏开头字母拼在一起组成的。RSA 算法的可靠性由极大整数因数分解的难度决定。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用 RSA 加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。如今，只有短的 RSA 密钥才可能被强力方式解破。到 2017 年为止，还没有任何可靠的攻击 RSA 算法的方式。 二、已知条件RSA的加密规则：$ \color{blue}{m^e \equiv c\pmod n}$RSA的解密规则：$\color{red}{c^d \equiv m\pmod n}$ 约束条件及规则说明： m为明文字符，c为密文字符 m为0到n-1之间的数值 n=pq，p,q为素数 φ(n)=(p-1)*(q-1) [根据欧拉定理] e与φ(n)互素 $ ed \equiv 1\pmod {φ(n)}$ 欧拉公式$m^φ(n) \equiv 1\pmod n$ 要根据加密规则，数论及欧拉定理，来证明解密公式正确性：$\color{red}{c^d \equiv m\pmod n}$ 三、证明过程step1、根据加密规则公式$ \color{blue}{m^e \equiv c\pmod n}$可以得出 $$c=m^e-kn$$step2、 将C带入解密公式，得到$$(m^e-kn)^d \equiv m\pmod n$$step3、左边的展开中，除了第一项以外，其他项都与n相乘过，所以可以直接忽略左边括号中的kn项目，即：$$m^{ed} \equiv m\pmod n$$step4、因为 $ed\equiv1 \pmod {φ(n)}$ 即： $$ed=hφ(n)+1$$step5、上述结论代入step3的公式，得到$$m^{hφ(n)+1} \equiv m \pmod n $$step6、分情况讨论6.1 、m与n互质（如果你已经忘了m和n是什么了，请往前再看一遍）根据欧拉定理$m^φ(n) \equiv 1\pmod n$ 得到 $m^{φ(n)}=kn+1$然后左右两边分别h次方得到(kn+1)的h次方还是kn+1只不过这里的k变了：$$(m^{φ(n)})^h=kn+1$$然后左右两边乘以m即得到$$m^{hφ(n)+1} \equiv m \pmod n $$6.2 、m与n不互质此时，由于n等于质数p和q的乘积，所以m必然等于kp或kq。以 m = kp为例，这时k与q必然互质。如果k与q 不为互质关系，则k=tq, m= tqp=tn, 但是按照RSA规范，m∈(0…n−1) m\in(0…n-1)m∈(0…n−1), m &lt; n的，所以k与q肯定是互质关系的。由于k与q互质，p与q互质，kp与q肯定互质，则根据欧拉定理，下面的式子成立：$$\Large (kp)^{ q-1} \equiv 1\pmod q$$进一步扩展，可得：$$ \Large [(kp)^{ q-1}]^{h(p-1)}\times kp \equiv kp\pmod q$$即$$\Large (kp)^{ed} \equiv kp\pmod q$$进一步改写成等式：$$\Large (kp)^{ed} = kp+tq$$显然，t能被p整除， 即t=t’p,可以得出$$\Large (kp)^{ed} = kp+t’pq$$ 因为m=kp, n=pq, 最后得出$$\Large m^{ed} \equiv m\pmod n$$解密公式得到完全证明。 四、关于共模攻击脚本（其他的脚本要求安一堆奇怪的包，在win10还装不上，这里贴一个野生的共模攻击脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# coding=utf-8import syssys.setrecursionlimit(10000000)&quot;&quot;&quot;选择相同的模 n 加密相同的信息 m&quot;&quot;&quot;helpstr = &apos;&apos;&apos;usage: c1 = m ^ e1 % n c2 = m ^ e2 % n&apos;&apos;&apos;def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception(&apos;modular inverse does not exist&apos;) else: return x % mdef main(): print(helpstr) n = int(input(&quot;input n: &quot;)) c1 = int(input(&quot;input c1: &quot;)) c2 = int(input(&quot;input c2: &quot;)) e1 = int(input(&quot;input e1: &quot;)) e2 = int(input(&quot;input e2: &quot;)) s = egcd(e1, e2) s1 = s[1] s2 = s[2] # 求模反元素 if s1 &lt; 0: s1 = - s1 c1 = modinv(c1, n) elif s2 &lt; 0: s2 = - s2 c2 = modinv(c2, n) m = (c1**s1)*(c2**s2) % n print(m)if __name__ == &apos;__main__&apos;: main()]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集模板&&杭电畅通工程demo]]></title>
    <url>%2F2018%2F12%2F30%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF-%E6%9D%AD%E7%94%B5%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8Bdemo%2F</url>
    <content type="text"><![CDATA[一、并查集的介绍 并查集（Union/Find）从名字可以看出，主要涉及两种基本操作:合并和查找。这说明，初始时并查集中的元素是不相交的，经过一系列的基本操作(Union)，最终合并成一个大的集合。而在某次合并之后，有一种合理的需求： 某两个元素是否已经处在同一个集合中了？因此就需要Find操作比如，若想知道某个元素 x 是否在集合 s1 中(Find操作)，返回集合 s1 的代表元素即可。这样，判断两个元素是否在同一个集合中也是很方便的，只要看find(x) 和 find(y) 是否返回同一个代表即可。 二、并查集的存储结构及实现分析2.1、存储结构并查集(大S)由若干子集合si构成，并查集的逻辑结构就是一个森林。si表示森林中的一棵子树。一般以子树的根作为该子树的代表。而对于实际的并查集的存储结构，可用一维数组和链表来实现。这里主要介绍一维数组的实现。假设一维数组s中的每个元素 s[i] 表示该元素 i 的父亲。这里有两个需要注意的地方：①我们用一维数组来存储并查集，数组的元素s[i]表示的是结点的父亲的位置。②数组元素的下标 i 则是结点的标识。如：s[5]=4，表示：结点5 的父亲 是结点4。 2.2、Union操作Union操作就是将两个不相交的子集合合并成一个大集合。简单的Union操作是非常容易实现的，因为只需要把一棵子树的根结点指向另一棵子树即可完成合并。 2.3、Find操作Find操作就是查找某个元素所在的集合，返回该集合的代表元素1234567int find(int x)&#123; int r=x; while(bin[r]!=r) r=bin[r]; return r;&#125; 这里find(int x)返回的是最里层递归执行后，得到的值。由于只有树根的父结点位置等于父节点数组里对应的值（bin[r]=r），故返回的是树根结点的标识。 2.4、路径压缩思想：我们一开始找到了x的父亲节点，之后，我们随着（X—&gt;X的祖先）这条路，一直把这条路上的所有节点的父节点都标记为祖先节点。从而加快了查找的速度。123456789101112131415int Find(int x)&#123; int k, j, r; r = x; while(r != parent[r]) //查找跟节点 r = parent[r]; //找到跟节点，用r记录下 k = x; while(k != r) //非递归路径压缩操作 &#123; j = parent[k]; //用j暂存parent[k]的父节点 parent[k] = r; //parent[x]指向跟节点 k = j; //k移到父节点 &#125; return r; //返回根节点的值 &#125; 三、例题畅通工程Problem Description某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ Input测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。注意:两个城市之间可以有多条道路相通,也就是说3 31 21 22 1这种输入也是合法的当N为0时，输入结束，该用例不被处理。 Output对每个测试用例，在1行里输出最少还需要建设的道路数目。 Sample Input4 21 34 33 31 21 32 35 21 23 5999 00 Sample Output10299812345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;int pre[1010]; int find(int x)&#123; int r,k,j; r=x; while(pre[r]!=r)&#123; r=pre[r]; &#125; k=x; while(k!=r)&#123; //路径压缩 j=pre[k]; pre[k]=r; k=j; &#125; return r;&#125;int main()&#123; int n,m; while(scanf(&quot;%d&quot;,&amp;n),n)&#123; int i,x,y,c,d; for(i=1;i&lt;=n;i++) pre[i]=i; scanf(&quot;%d&quot;,&amp;m); for(i=1;i&lt;=m;i++)&#123; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); c=find(x); d=find(y); if(c!=d) //合并 &#123; pre[d]=c; &#125; &#125; int count=-1; for(i=1;i&lt;=n;i++)&#123; if(pre[i]==i) count++; &#125; printf(&quot;%d\n&quot;,count); &#125; return 0;&#125;]]></content>
      <categories>
        <category>NUAA那点事</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu中Docker的安装&&遇到的坑&&简单命令]]></title>
    <url>%2F2018%2F12%2F28%2Fubuntu%E4%B8%ADDocker%E7%9A%84%E5%AE%89%E8%A3%85-%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91-%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1、前提条件 本博客基于ubuntuDocker 要求 Ubuntu 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的 Ubuntu 版本是否支持 Docker。通过 uname -r 命令查看你当前的内核版本1runoob@runoob:~$ uname -r 2、安装 Docker2.1、获取最新版本的 Docker 安装包1runoob@runoob:~$ wget -qO- https://get.docker.com/ | sh 输入当前用户的密码后，就会下载脚本并且安装Docker及依赖包。安装完成后有个提示：1234 If you would like to use Docker as a non-root user, you should now consider adding your user to the &quot;docker&quot; group with something like: sudo usermod -aG docker runoobRemember that you will have to log out and back in for this to take effect! 2.2、速度很慢怎么慢修改/etc/docker/daemon.json 文件为1&#123;&quot;registry-mirrors&quot;: [&quot;http://4e70ba5d.m.daocloud.io&quot;]&#125; 或者直接用下面脚本跑（真香，ID可以自己在daocloud配123root@ubuntu:~# curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://4e70ba5d.m.daocloud.ioroot@ubuntu:~# cat /etc/docker/daemon.json &#123;&quot;registry-mirrors&quot;: [&quot;http://4e70ba5d.m.daocloud.io&quot;]&#125; 然后重启1root@ubuntu:~# service docker restart 2.3、无法获得锁 /var/lib/apt/lists/lock - open (11: 资源暂时不可用)出现这个问题的原因可能是有另外一个程序正在运行，导致资源被锁不可用。而导致资源被锁的原因，可能是上次安装时没正常完成，而导致出现此状况。有两种方法1、通过删除文件（实测方法2友好一些12sudo rm /var/cache/apt/archives/locksudo rm /var/lib/dpkg/lock 2、通过ps查看apt-get的PID 然后sudo kill 就可以 3、然后就是基本命令3、1:添加用户组默认来说docker只能sudo运行为了下次方便使用，可以添加用户到docker用户组1sudo usermod -aG docker $&#123;USER&#125; 然后下次登陆即可非root使用docker 3、2:查看Docker版本信息1docker version 3、3: 查看本地镜像1docker images 3、4：容器从哪里来开始如果你什么镜像都没有，你想要一个ubuntu的镜像可以直接下载123kitty@ubuntu:~$ docker pull ubuntu或者kitty@ubuntu:~$ docker run ubuntu 比如你要一个nginx镜像然后你就可以使用docker images 查看安装了哪些 3、5：普通运行docker run -t -i ubuntu /bin/bash命令指定使用镜像ubuntu来启动一个容器 其中要保证ubuntu是images中已经存在的镜像-it 表示运行在交互模式，是-i -t的缩写，即-it是两个参数：-i和-t。前者表示打开并保持stdout，后者表示分配一个终端（pseudo-tty）一般这个模式就是可以启动bash，然后和容器有命令行的交互 3、6：查看当前正在运行的容器：1~$ docker ps 其中加上-a 表示查看所有的容器，包括已经停了的 3、7：启动、停止、重启容器123~$ docker start aa97ba3292ce~$ docker stop aa97ba3292ce~$ docker restart aa97ba3292ce 和容器有关的一般是容器的ID 3、8： 删除镜像或者容器12~$ docker rm container_id~$ docker rmi image_id 如果遇到了问题比如占用等加上参数 -f 一梭子下去就完事了（docker rm -f container_id 4、跑一个nginx当demo玩玩4.1、安装nginx1kitty@ubuntu:~$ docker pull nginx 4.2、通过docker images确认安装后运行一下其中–name 后面接的是images名也就是 REPOSITORY对应的东西-p后面的第一个8888是本地端口，80是nginx的端口，意思是将nginx端口映射到本地,现在可以访问本地8888端口 4.3、使用自写的界面先本地随便写一个index.html 然后当运行一个容器的时候，将该html替换进容器的index.html了至于文件目录问题就要我们自己了解了 53be82f8c182这个东西是容器的ID然后访问 当然这个只是在容器中修改如果要完全保存起来，你需要学commit等操作形成新的镜像，本篇文章旨在入门，所以其他的希望看到本博客的能去自学，坚持下去，就是大佬了Orz。最后附上一张高大上的Docker命令图,望君笑纳]]></content>
      <categories>
        <category>计算机♂操作</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[万物美好，世间温柔]]></title>
    <url>%2F2018%2F12%2F27%2F%E4%B8%87%E7%89%A9%E7%BE%8E%E5%A5%BD%EF%BC%8C%E4%B8%96%E9%97%B4%E6%B8%A9%E6%9F%94%2F</url>
    <content type="text"><![CDATA[整理文件发现了几张初中高中画的画，当初也曾经想过大学学美术，最后还是跟着潮流学了计算机，曾经想过如果家里有钱，我还真去学美术的（当然也不是说学美术就赚不到钱，但是学计算机毕竟现在能独立生活，也曾经想过在大学里，左手程式右手诗，有空就画画，吉他，读诗（想想好中二啊）但是想想而来，入大学到现在，这个“有空”从何而来，也算是我背叛了当初的梦想而苟活至今，当然这也是时代的必然发展，就好比入了大学你有多久没开心一笑了。大学时间过的太快，真的太快，快到你没空停下来看一场电影，但是高三却能追完整个火影。突然看到曾经的画，对于当初那份快乐，现在除了鼻子酸酸，真的只有回味了。望你我珍惜大学时光，不负韶华。想了一下还是留几张照片放这里，希望自己能好好生活当一个正常人，当然从技术而言，肯定没法比艺术生，闻道有先后，术业有专攻 给老姐的生日礼物 大爱鸣雏 夏目 大爱火影（好中二啊 wsl 奇奇怪怪的一些垃圾 我也不知道是谁的谁 唯一喜欢的就是右图辣个蓝人 总感觉这个忙碌的人和我有某种关系♂]]></content>
      <categories>
        <category>万物可爱，世间温柔</category>
      </categories>
      <tags>
        <tag>画画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何建立huffmanTree]]></title>
    <url>%2F2018%2F12%2F27%2F%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8BhuffmanTree%2F</url>
    <content type="text"><![CDATA[1、一些基本概念1.1、定义哈夫曼树，又称最优树，是一类带权路径长度最短的树(为了防止前缀重复，所有数据一定为树叶)。 1.2、路径和路径长度从树中一个结点到另一个结点之间的分支构成两个结点的路径，路径上的分支数目叫做路径长度。树的路径长度是从树根到每一个结点的路径长度之和。 1.3、带权路径长度结点的带权路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和，通常记作WPL。 若有n个权值为w1,w2,…,wn的结点构成一棵有n个叶子结点的二叉树，则树的带权路径最小的二叉树叫做哈夫曼树或最优二叉树。在上图中，3棵二叉树都有4个叶子结点a、b、c、d，分别带权7、5、2、4，则它们的带权路径长度为 （a）WPL = 7 2 + 5 2 + 2 2 + 4 2 = 36 （b）WPL = 4 2 + 7 3 + 5 3 + 2 1 = 46 （c）WPL = 7 1 + 5 2 + 2 3 + 4 3 = 35 其中（c）的WPL最小，可以验证，（c）恰为哈夫曼树。 2、数据结构表示2.1、结点表示12345typedef struct&#123; int weight; int parent; int lchild,rchild;&#125;HuffmanTreeNode; 2.2、一些数据关系1、哈夫曼树除了根结点，其他结点度数都为22、m=2n-1(m代表总结点个数，n代表树叶结点个数)证明:因为 结点总数=度数为0 1 2之和=度数为1+ 2度数为2 +1（根节点）所以 叶子结点数=度数为2的结点数+1所以total=叶子+度数为2=2*n-1 得证 2.3、初始状态 2.4、最终状态 3、创建哈夫曼树步骤假设有n个结点，n个结点的权值分别为w1,w2,…,wn，构成的二叉树的集合为F={T1,T2,…,Tn}，则可构造一棵含有n个叶子结点的哈夫曼树。步骤如下：（1）从F中选取两棵根结点权值最小的树作为左右子树构造一棵新的二叉树，其新的二叉树的权值为其左右子树根结点权值之和； （2）从F中删除上一步选取的两棵二叉树，将新构造的树放到F中； （3）重复（1）（2），直到F只含一棵树为止。 4、哈夫曼编码我们约定左分支表示字符’0’，右分支表示字符’1’，在哈夫曼树中从根结点开始，到叶子结点的路径上分支字符组成的字符串为该叶子结点的哈夫曼编码。上面代码所创建的哈夫曼树如下所示：可以看出3被编码为00，1为010，2为011,4为10,5为11。在这些编码中，任何一个字符的编码均不是另一个字符编码的前缀。 5、C++建立haffmanTree123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;cstdlib&gt;#include&lt;vector&gt;using namespace std;typedef struct&#123; int weight; int parent; int lchild,rchild;&#125;HuffmanTreeNode;int min(HuffmanTreeNode* &amp;tree,int k)&#123; int minnum,min_weight; int i=0; while(tree[i].parent!=-1) i++;//先将第一个parent为-1的元素的weight值赋给min_weight,留作以后比较用。 min_weight=tree[i].weight; minnum=i; for(;i&lt;k;i++) &#123; if(tree[i].weight&lt;min_weight&amp;&amp;tree[i].parent==-1) &#123; min_weight=tree[i].weight; minnum=i; &#125; &#125; tree[minnum].parent=1; return minnum;&#125;void Select(HuffmanTreeNode * &amp;tree,int k ,int &amp; i1,int &amp; i2)&#123; i1=min(tree,k); i2=min(tree,k);&#125;void HaffmanTree(HuffmanTreeNode * &amp; tree,int w[],int n)&#123; for(int i=0;i&lt;2*n-1;i++) &#123; tree[i].parent=-1; tree[i].lchild=-1; tree[i].rchild=-1; &#125; for(int i=0;i&lt;n;i++) tree[i].weight=w[i]; int i1,i2; for(int k=n;k&lt;2*n-1;k++) &#123; Select(tree,k,i1,i2);//前K个找最小和第二小 tree[k].weight=tree[i1].weight+tree[i2].weight; tree[i1].parent=k; tree[i2].parent=k; tree[k].lchild=i1; tree[k].rchild=i2; &#125; cout&lt;&lt;&quot;建哈夫曼树成功:\n&quot;; for (int i=0; i&lt;2*n-1; i++) &#123; cout&lt;&lt;tree[i].weight&lt;&lt;&quot; &quot;&lt;&lt;tree[i].parent&lt;&lt;&quot; &quot;&lt;&lt;tree[i].lchild&lt;&lt;&quot; &quot;&lt;&lt;tree[i].rchild&lt;&lt;endl; &#125;&#125;void ShowHaffmanCoding(HuffmanTreeNode* tree,int n)&#123; int w=2*n-1; vector&lt;stack &lt;char&gt; &gt;HuffmanCode; stack&lt;char&gt;temp; cout&lt;&lt;&quot;debug1&quot;&lt;&lt;endl; //从结点开始找双亲 for(int i=0;i&lt;n;i++)&#123; cout&lt;&lt;&quot;debug2&quot;&lt;&lt;endl; int j=i; int parent= tree[i].parent;//找到双亲 while(parent!=-1) &#123; if(tree[parent].lchild==j) temp.push(&apos;0&apos;);//如果是左孩子 else temp.push(&apos;1&apos;);//右孩子 int j=parent; parent=tree[j].parent;//直到根结点结束 &#125; HuffmanCode.push_back(temp); while(!temp.empty()) temp.pop(); &#125; for(int i=0;i&lt;n;i++) &#123; cout&lt;&lt;&quot;第&quot;&lt;&lt;i+1&lt;&lt;&quot;个数的权值为 : &quot;&lt;&lt;tree[i].weight&lt;&lt;&quot; 编码为： &quot;; while(!HuffmanCode[i].empty()) &#123; cout&lt;&lt;HuffmanCode[i].top(); HuffmanCode[i].pop(); &#125; cout&lt;&lt;endl; &#125;&#125;int main()&#123; cout&lt;&lt;&quot;请输入权值个数n\n&quot;; int n=0; cin&gt;&gt;n; int m=2*n-1; HuffmanTreeNode * tree=(HuffmanTreeNode *)malloc(sizeof(HuffmanTreeNode)*m); for(int i=0;i&lt;m;i++)&#123; tree[i].weight=tree[i].parent=tree[i].lchild=tree[i].rchild=0; &#125; cout&lt;&lt;&quot;请输入权值: \n&quot;; int w[n]; for(int i=0;i&lt;n;i++) cin&gt;&gt;w[i]; HaffmanTree(tree,w,n); ShowHaffmanCoding(tree,n);&#125;]]></content>
      <categories>
        <category>NUAA那点事</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图的DFS和BFS算法分析]]></title>
    <url>%2F2018%2F12%2F27%2F%E5%9B%BE%E7%9A%84DFS%E5%92%8CBFS%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1、图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似。它的思想：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。显然，深度优先搜索是一个递归的过程。 1.1、深度优先搜索图解 访问A。 访问(A的邻接点)C。 在第1步访问A之后，接下来应该访问的是A的邻接点，即”C,D,F”中的一个。但在本文的实现中，顶点ABCDEFG是按照顺序存储，C在”D和F”的前面，因此，先访问C。 访问(C的邻接点)B。 在第2步访问C之后，接下来应该访问C的邻接点，即”B和D”中一个(A已经被访问过，就不算在内)。而由于B在D之前，先访问B。 访问(C的邻接点)D。 在第3步访问了C的邻接点B之后，B没有未被访问的邻接点；因此，返回到访问C的另一个邻接点D。 访问(A的邻接点)F。 前面已经访问了A，并且访问完了”A的邻接点B的所有邻接点(包括递归的邻接点在内)”；因此，此时返回到访问A的另一个邻接点F。 访问(F的邻接点)G。 访问(G的邻接点)E。因此访问顺序是：A -&gt; C -&gt; B -&gt; D -&gt; F -&gt; G -&gt; E1.2、C++ DFS代码1234567891011121314151617181920212223242526272829303132333435/* * 深度优先搜索遍历图的递归实现 */void ListDG::DFS(int i, int *visited)&#123; ENode *node; visited[i] = 1; cout &lt;&lt; mVexs[i].data &lt;&lt; &quot; &quot;; node = mVexs[i].firstEdge; while (node != NULL) &#123; if (!visited[node-&gt;ivex]) DFS(node-&gt;ivex, visited); node = node-&gt;nextEdge; &#125;&#125;/* * 深度优先搜索遍历图 */void ListDG::DFS()&#123; int i; int visited[MAX]; // 顶点访问标记 // 初始化所有顶点都没有被访问 for (i = 0; i &lt; mVexNum; i++) visited[i] = 0; cout &lt;&lt; &quot;DFS: &quot;; for (i = 0; i &lt; mVexNum; i++) &#123; if (!visited[i]) DFS(i, visited); &#125; cout &lt;&lt; endl;&#125; 2、广度优先搜索算法(Breadth First Search)，又称为”宽度优先搜索”或”横向优先搜索”,相当于树的层次遍历，简称BFS。它的思想是：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2…的顶点。 2.1、广度优先搜索图解 访问A。 依次访问C,D,F。 在访问了A之后，接下来访问A的邻接点。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，C在”D和F”的前面，因此，先访问C。再访问完C之后，再依次访问D,F。 依次访问B,G。 在第2步访问完C,D,F之后，再依次访问它们的邻接点。首先访问C的邻接点B，再访问F的邻接点G。 访问E。 在第3步访问完B,G之后，再依次访问它们的邻接点。只有G有邻接点E，因此访问G的邻接点E。因此访问顺序是：A -&gt;C-&gt; D -&gt; F -&gt; B -&gt; G -&gt; E2.2、C++ BFS代码12345678910111213141516171819202122232425262728293031323334353637383940414243/* * 广度优先搜索（类似于树的层次遍历） */void ListDG::BFS()&#123; int head = 0; int rear = 0; int queue[MAX]; // 辅组队列 int visited[MAX]; // 顶点访问标记 int i, j, k; ENode *node; for (i = 0; i &lt; mVexNum; i++) visited[i] = 0; cout &lt;&lt; &quot;BFS: &quot;; for (i = 0; i &lt; mVexNum; i++) &#123; if (!visited[i]) &#123; visited[i] = 1; cout &lt;&lt; mVexs[i].data &lt;&lt; &quot; &quot;; queue[rear++] = i; // 入队列 &#125; while (head != rear) &#123; j = queue[head++]; // 出队列 node = mVexs[j].firstEdge; while (node != NULL) &#123; k = node-&gt;ivex; if (!visited[k]) &#123; visited[k] = 1; cout &lt;&lt; mVexs[k].data &lt;&lt; &quot; &quot;; queue[rear++] = k; &#125; node = node-&gt;nextEdge; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>NUAA那点事</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[先序+中序建树法]]></title>
    <url>%2F2018%2F12%2F26%2F%E5%85%88%E5%BA%8F-%E4%B8%AD%E5%BA%8F%E5%BB%BA%E6%A0%91%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、假如有棵树是这样滴 2、当然我们现在开始假装不知道有这么棵树，但是知道先序： 1 2 3 4 5 6中序： 3 2 4 1 6 5 3、建树步骤 root最简单，前序遍历的第一节点“1”就是root 那就观察中序遍历“ 3, 2, 4, 1, 6, 5”。其中root节点“1”左侧的“3, 2, 4”必然是root的左子树，“1”右侧的“6, 5”必然是root的右子树 观察左子树“3, 2, 4”，左子树的中的根节点必然是大树的root的leftchild。在前序遍历中，大树的root的leftchild位于root之后，所以左子树的根节点为” 2 “. 同样的道理，root的右子树节点“6，5”中的根节点也可以通过前序遍历求得,root为5（通过先序遍历获取。 通过中序遍历去数节点的个数判断是前序遍历中的左子树和右子树的分界线。在上一次中序遍历中，root左侧是“3，2，4”，所以有3个节点位于root左侧。那么在前序遍历中，必然是第1个是“1”，第2到第4个由“2，3，4”构成，第5个就是root的右子树的根节点了，是“5”。 如此递归4、C++代码12345678910111213141516171819202122232425262728293031typedef struct BTNode &#123; char data; BTNode *lchild, *rchild;&#125;BTNode, *BiTree;// 先序+中序 建树法void CreateBiTree(BiTree &amp;bTree, string preOrder, string inOrder) &#123; bTree = (BTNode*)malloc(sizeof(BTNode)); bTree-&gt;data = preOrder[0]; int pos = inOrder.find(preOrder[0]); string inOrderL = inOrder.substr(0, pos); string inOrderR = inOrder.substr(pos + 1, inOrder.length() - 1); string preOrderL = preOrder.substr(1, inOrderL.length()); string preOrderR = preOrder.substr(inOrderL.length() + 1, preOrder.length() - 1); bool isEmptyL = false, isEmptyR = false; // 用来判断左右结点是否为空的标志位 if (inOrderL.empty()) &#123; bTree-&gt;lchild = NULL; isEmptyL = true; &#125; if (inOrderR.empty()) &#123; bTree-&gt;rchild = NULL; isEmptyR = true; &#125; if (!isEmptyL) &#123; CreateBiTree(bTree-&gt;lchild, preOrderL, inOrderL); &#125; if (!isEmptyR) &#123; CreateBiTree(bTree-&gt;rchild, preOrderR, inOrderR); &#125; &#125; 然后当然也就知道了后序遍历为：3，4，2，6，5，1]]></content>
      <categories>
        <category>NUAA那点事</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSAPP又双叒叕来一遍之链接]]></title>
    <url>%2F2018%2F12%2F21%2FCSAPP%E5%8F%88%E5%8F%8C%E5%8F%92%E5%8F%95%E6%9D%A5%E4%B8%80%E9%81%8D%E4%B9%8B%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[整体看本章（第七章讲了啥）链接是将各种不同文件的代码和数据部分收集（符号解析和重定位）起来并组合成一个单一文件的过程。 目标文件三种形式：1、可重定位目标文件：包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。2、可执行目标文件：包含二进制代码和数据，其形式可以直接拷贝到存储器并执行。3、共享目标文件：一种特殊类型的可重定位目标文件，可以在加载或运行时被动态地加载到存储器并链接。 看一下GCC做了哪些事情 细讲最后一步链接器（ld）做了啥1、符号解析。目标文件定义和引用符号，符号解析的目的是将每个符号引用和一个符号定义联系起来；2、重定位：把每个符号定义与一个存储器位置联系起来，然后修改对这些符号的引用，是的他们指向这个存储器位置，从而实现重定位。 链接器操作的目标文件目标文件一般是由汇编器生成的.o后缀的文件，大概有三种不同的形式：可重定位目标文件；可执行目标文件和共享目标文件。我们接下来讨论的目标文件是基于Unix系统的ELF格式（Exxcutable and Linkable Format），这同Windows系统上的PE（Portable Executable）文件格式在基本概念上其实是相似的：一个典型的ELF可重定位目标文件的格式：1234567.text：已编译程序的机器码；.rodata：只读数据（read-only-data）；.data：已初始化的全局C变量；.bss：未初始化的全局C变量（better save space）;.symtab：一个符号表（定义和引用的函数和全局变量信息）；.rel.text：代码重定位条目， 一个.text节中位置的列表，需要修改的位置;.rel.data: 被模块引用或定义的任何全局变量的重定位信息；.debug：一个调试符号表； .line：原始C源程序中的行号和.text机器指令的映射；.strtab: 一个字符串表 ld任务一 符号解析（符号和符号表）保存于.symtab中的是一个符号表，其是定义和引用函数和全局变量的信息。有三种不同类型的符号：全局符号（不带static），外部引用（external）和本地符号。如果是带有static符号的就会在.data和.bss中为每个定义分配空间，并在.symtab中创建一个唯一名字的本地符号。比如：中有两个static定义的x变量，其会在.data中分配空间，并在.symtab中创建两个，x.1表示f函数的定义和x.2表示函数g的定义。（注：使用static可以保护你自己的变量和函数）符号解析任务简单的说，就是链接器使得所有模块中的每个符号只有一个定义。链接器在这一个阶段的主要任务就是把代码中的每个符号引用和确定的一个符号定义联系起来。对于本地符号，这个任务相对来说是简单的。复杂的就是全局符号，编译器（cc1）遇到不是在当前模块中定义的符号时，会假设该符号的定义在其他模块中，生成一个链接器符号交给链接器处理。如果链接器ld在所有的模块中都找不到定义的话就会抛出异常。 如何链接和解析静态库像printf等一些常用的函数，都是在libc.a静态库中，静态库以一种存档的特殊文件（.a）格式，将可以定位的目标文件集合成一个.a文件。 ld任务二 重定位完成了符号解析以后，链接器的第二个任务就是合并输入模块，并为每个符号分配运行时的地址。重定位节和符号定义：在这一步中，链接器将所有模块中的.data节合并成一个文件的.data节，运行时存储器的地址也会赋给新的聚合节。然后就是，重定位节中的符号引用：链接器修改代码节和数据节中对每个符号的引用，使得他们指向正确的运行时地址。这一步要用到重定位条目这一数据结构，我们来描述这个过程： 可执行目标文件格式通过前面知识的学习，我们了解到链接器主要完成了两个工作，符号解析和重新定义。将数据和代码合并成为一个可执行的文件，接下来我们看看这个可执行文件的格式是什么，以及如何加载到存储器中开始运行的过程。12ELF头部：描述文件总体格式，标注出程序入口点；.init：定义了初始化函数;段头部表：可执行文件是一个连续的片，段头部表中描述了这种映射关系； 动态链接共享库1、 编译时加载静态库需要定期的维护和更新，调用的代码还会拷贝到每个运行的进程中去，这是对存储器系统资源的极大浪费。为了弥补这样的缺陷，我们发明了共享库。共享库的一个主要目的就是允许多个正在运行的进程共享存储器中相同的库代码，节约资源。以(.so)结尾的文件，在运行时被加载到任意存储器地址，并和存储器中的程序链接起来，以后的进程要用到这个库就从这个固定的位置开始访问。这一过程的管理交由动态链接器程序来执行。2、运行时加载共享库微软的windows程序开发人员提供共享库来更新软件，通常要求下载最新的dll库，然后在程序下一次执行的时候会自动链接和加载更新后的共享库。我们创建dll.c文件，运行时加载libvector.so]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>链接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSAPP又双叒叕来一遍之函数调用过程栈帧的变化]]></title>
    <url>%2F2018%2F12%2F21%2FCSAPP%E5%8F%88%E5%8F%8C%E5%8F%92%E5%8F%95%E6%9D%A5%E4%B8%80%E9%81%8D%E4%B9%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E6%A0%88%E5%B8%A7%E7%9A%84%E5%8F%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[函数调用在第三章第七章均有涉及，故专门总结一波函数调用栈帧的变化1、熟悉一下程序的进程空间 ，即对进程如何使用内存先讨论32位的计算机，计算机物理内存的大小是固定的，就是计算机主板内存槽上的实际物理内存，cpu可以直接进行寻址，物理内存的容量是固定的，但是寻址的空间取决于cpu地址线的数量。在32位系统上，线性地址空间可达4G（2^32）；这4G一般是按照3：1的比例进行分配，用户进程享有3G的空间，而内核独自享有剩下的1G内存 2、谈谈栈帧的概念栈帧(stack frame)，机器用栈来传递过程参数，存储返回信息，保存寄存器用于以后恢复，以及本地存储。为单个过程(函数调用)分配的那部分栈称为栈帧。栈帧其实 是两个指针寄存器，寄存器%ebp为帧指针（指向该栈帧的最底部），而寄存器%esp为栈指针（指向该栈帧的最顶部），当程序运行时，栈指针可以移动(大多数的信息的访问都是通过帧指针的，换句话说，就是如果该栈存在，%ebp帧指针是不移动的，访问栈里面的元素可以用-4(%ebp）或者8(%ebp)访问%ebp指针下面或者上面的元素)。总之简单 一句话，栈帧的主要作用是用来控制和保存一个过程的所有信息的。栈帧结构如下所示：大概解释：假设过程P（调用者）调用过程Q（被调用者），则Q的参数放在P的栈帧中。另外，当P调用Q时，P中的返回地址被压入栈中，形成P的栈帧的末尾 （返回地址就是当程序从Q返回时应该继续执行的地方）。Q的栈帧从保存的帧指针的值开始，后面到新的栈指针之间就是该过程的部分了。 3、函数具体调用示例源代码（忽略主函数）:123456789101112131415int swap_add(int* xp,int* yp) &#123; int x = *xp; int y = *yp; *xp = y; *yp = x; return x+y;&#125;int caller()&#123; int arg1 = 534; int arg2 = 1057; int sum = swap_add(&amp;arg1,&amp;arg2); int diff = arg1 - arg2; return sum * diff;&#125; 经过汇编之后caller部分的代码为：1234567891011121314151617caller: pushl %ebp //保存%ebp movl %esp,%ebp //设置新的帧指针为旧的栈指针 subl $24,%esp //分配24子节的栈空间 movl $534,-4(%ebp) //设置arg1=534 movl $1057,-8(%ebp) //设置arg2=1057 leal -8(%ebp),%eax //计算&amp;arg2 movl %eax,4(%esp) //将&amp;arg2存入栈中 leal -4(%ebp),%eax //计算&amp;arg1 movl %eax,(%esp) //将&amp;arg1存入栈中 call swap_add //调用swap_add-------------------》过程调用 movl -4(%ebp),%edx /从栈中取出arg1,和arg2的值 subl -8(%ebp),%edx //为了计算diff, imull %edx,%eax leave //为返回准备栈，GCC 产生的代码有时候会使用leave指令来释放栈帧， //而有时会使用一个或者两个popl指令。两个方法都可行。 ret //从过程调用中返回 这段代码先保存了%ebp的一个副本，将新的过程（该函数的ebp）的ebp设置为栈帧的开始位置。然后将栈指针减去24，从而在栈上分配了24字 节的空间（你应该思考一下为什么是24字节,记得有两个为保存的寄存器），然后是初始化两个局部变量，计算两个局部变量的地址并存入栈中，形成了函数swap_add的参数。将这些 参数存储到相对于栈指针偏移量为0和+4的地方，留待稍后的swap_add调用访问。然后调用swap_add12345678910111213141516swap_add: pushl %ebp //save old %ebp movl %esp,%ebp //set %ebp as frame pointer pushl %ebx //save %ebx movl 8(%ebp),%edx //Get xp movl 12(%ebp),%ecx //Get yp movl (%edx),%ebx //Get x movl (%ecx),%eax //Get u movl %eax,(%edx) //Store y as xp movl %ebx,(%ecx) //Sotre x as yp addl %ebx,%eax //return value = x + y popl %ebx //restore %ebx popl %ebp //restore %ebp ret //从过程调用中返回, 将控制转移回caller 说明三点，1、说明一点程序在执行到swap_add的代码之前，也就是在执行call语句已经把返回地址压入栈中，包括%esp-4. 2、最后一部 分的popl %ebx popl %ebp。它的作用是恢复了之前存储的栈帧指针的值. 3、返回值是存入了%eax中，在接下来的调用程序caller中直接访问该寄存器 整个过程的栈变化如下所示]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>栈帧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10环境下使用virtualenv搭建py虚拟环境]]></title>
    <url>%2F2018%2F12%2F20%2Fwin10-%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8virtualenv%E6%90%AD%E5%BB%BApy%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[virtualenv干啥的python2与python3版本不兼容确实很蛋疼，虽然随着时间发展python3一定会将python2取代但是确实现在还有很多项目依赖于python2，virtualenv通过创建一个虚拟化的python运行环境，将我们所需的依赖安装进去的，不同项目之间相互不干扰。 安装 virtualenv1pip install virtualenv 配置操作如果是想搭建一个与目前本机python版本相同的环境，就只需要在某文件目录下直接输入命令(venvdmo可随意)1virtualenv venvdemo 如果本机为py3，想搭建一个py2的虚拟环境输入以下命令(venvdmo可随意)1virtualenv -p &#123;你的py2的路径&#125;/python.exe venvdemo 这时候便会在当前的项目中创建venv文件夹，为当前项目的虚拟python运行环境 激活和冻结在windows中 virtualenv新建一个文件在venvdemo/Scripts中有activate.bat与deactivate.bat用以激活12345678# 定位到新建虚拟环境env 的Script 目录下activate.bat#虚拟环境处于激活状态，显示如下#(env)C:\Users\env\Scripts&gt;# 冻结env 环境#deactivate.bat# 输入deactivate.bat命令后，冻结状态显示如下#C:\Users\env\Scripts&gt; virtualenvwrapper-win 安装 和使用virtualenvwrapper-win 是Windows下对于虚拟环境的管理工具，相当于你有很多小工具，现在买一个工具包来整理一下这些小工具 安装1pip install virtualenvwrapper-win 配置首先，设置virtualenvwrapper-win 的默认环境目录 ： 在win10中，添加系统环境变量 WORKON_HOME,指向 path/dir (自己想要的虚拟环境目录位置，之后将在这个固定文件下搭建环境) 进入和退出虚拟环境查看当前有哪些环境1lsvirtualenv或者workon 进入某个环境1workon &#123;环境的名字&#125; 退出某个环境1deactivate &#123;环境的名字&#125; 顺便唠两下关于查看与迁移pip安装的包查看pip 安装过的包1pip list 生成requirements.txt文件1pip freeze &gt;requirements.txt 将在命令行当前目录下生成一个requirements.txt文件为当前pip安装包的各名称 新环境的安装切换到requirements.txt所在的文件夹下 1pip install -r requirements.txt]]></content>
      <categories>
        <category>计算机♂操作</category>
      </categories>
      <tags>
        <tag>virtualenv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种源使用国内镜像简单配置]]></title>
    <url>%2F2018%2F12%2F20%2F%E5%90%84%E7%A7%8D%E6%BA%90%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[windows环境下 pip换国内镜像1、打开user目录，user目录可以通过win+R 然后添加 %APPDATA% (不区分大小写)2、直接在中创建一个pip目录，如：C:\Users\xx\pip，新建文件pip.ini：3、拿任意文本编辑器打开，添加以下内容1234[global]timeout = 6000index-url = http://pypi.douban.com/simpletrusted-host = pypi.douban.com 保存即可 Ubuntu环境下 pip换国内镜像1、在主目录下创建.pip文件夹,然后在该目录下创建pip.conf文件12mkdir ~/.pipvim ~/.pip/pip.conf 2、pip.conf文件编写如下内容（更换为清华大学镜像源）：12[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple Ubuntu更换系统源1、复制原文件备份1sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 2、编辑源列表文件(对vim不熟可使用gedit)1sudo vim /etc/apt/sources.list 3、将原来的列表删除，添加如下内容12345678910deb http://mirrors.aliyun.com/ubuntu/ vivid main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ vivid-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ vivid-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ vivid-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ vivid-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ vivid main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ vivid-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ vivid-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ vivid-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ vivid-backports main restricted universe multiverse 4、更新本地索引列表运行12sudo apt-get update #更新本地索引列表#sudo apt-get upgrade # 可选/根据更新的索引升级已安装的所有软件包]]></content>
      <categories>
        <category>计算机♂操作</category>
      </categories>
      <tags>
        <tag>换源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用python进行两位十六进制换字符串]]></title>
    <url>%2F2018%2F12%2F14%2F%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E4%B8%A4%E4%BD%8D%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[如果你只是简单的解码或编码一个十六进制的原始字符串，可以使用 binascii 模块。例如：1234567&gt;&gt;&gt; s = b&apos;hello&apos;&gt;&gt;&gt; import binascii&gt;&gt;&gt; h = binascii.b2a_hex(s)&gt;&gt;&gt; hb&apos;68656c6c6f&apos;&gt;&gt;&gt; binascii.a2b_hex(h)b&apos;hello&apos; 类似的功能同样可以在 base64 模块中找到。例如：12345678&gt;&gt;&gt; s = b&apos;hello&apos;&gt;&gt;&gt; import base64&gt;&gt;&gt; h = base64.b16encode(s)&gt;&gt;&gt; hb&apos;68656C6C6F&apos;&gt;&gt;&gt; base64.b16decode(h)b&apos;hello&apos;&gt;&gt;&gt; 讨论:大部分情况下，通过使用上述的函数来转换十六进制是很简单的。 上面两种技术的主要不同在于大小写的处理。 函数 base64.b16decode() 和 base64.b16encode() 只能操作大写形式的十六进制字母， 而 binascii 模块中的函数大小写都能处理。 还有一点需要注意的是编码函数所产生的输出总是一个字节字符串。 如果想强制以Unicode形式输出，你需要增加一个额外的界面步骤。例如：123456&gt;&gt;&gt; h = base64.b16encode(s)&gt;&gt;&gt; print(h)b&apos;68656C6C6F&apos;&gt;&gt;&gt; print(h.decode(&apos;ascii&apos;))68656C6C6F&gt;&gt;&gt;]]></content>
      <categories>
        <category>计算机♂操作</category>
      </categories>
      <tags>
        <tag>进制转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gcc && gdb]]></title>
    <url>%2F2018%2F12%2F06%2Fgcc-gdb%2F</url>
    <content type="text"><![CDATA[一、GCC参数详解什么是gccgcc的全称是GNU Compiler Collection，它是一个能够编译多种语言的编译器。最开始gcc是作为C语言的编译器（GNU C Compiler），现在除了c语言，还支持C++、java、Pascal等语言。gcc支持多种硬件平台。 gcc 与 g++ 分别是 gnu 的 c &amp; c++ 编译器 gcc/g++ 在执行编译工作的时候，总共需要4步： 预处理,生成 .i 的文件[预处理器cpp] 将预处理后的文件不转换成汇编语言, 生成文件 .s [编译器egcs] 有汇编变为目标代码(机器代码)生成 .o 的文件[汇编器as] 连接目标代码, 生成可执行程序 [链接器ld]来看一下gcc常用选项：现在我们有源文件hello.c，下面是一些gcc的使用示例：1234567gcc -E hello.c -o hello.i 对hello.c文件进行预处理，生成了hello.i 文件gcc -S hello.i -o hello.s 对预处理文件进行编译，生成了汇编文件gcc -c hello.s -o hello.o 对汇编文件进行编译，生成了目标文件gcc hello.o -o hello 对目标文件进行链接，生成可执行文件gcc hello.c -o hello 直接编译链接成可执行目标文件gcc -c hello.c 或 gcc -c hello.c -o hello.o 编译生成可重定位目标文件gcc -Og -S hello.c 生成汇编 二、GDB入门教程什么是GDBGDB（The GNU Debugger），是GNU开源组织发布的一个强大的UNIX程序调试工具。如果你是在 UNIX平台下开发软件，你会发现GDB这个调试工具有比VC、BCB的图形化调试工具拥有更强大的功能。同时GDB也具有例如DDD调试器，全称是Data Display Debugger这样的图形化调试端。 一般来说，GDB主要完成下面四个方面的功能：(1)启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。(2)可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）(3)当程序被停住时，可以检查此时你的程序中所发生的事。(4)动态的改变程序的执行环境。 GDB通常和gcc命令一起使用，编译选项加入-g才可使可执行文件处于debug模式。gdb命令格式：123gdb [-help] [-nx] [-q] [-batch] [-cd=dir] [-f] [-b bps] [-tty=dev] [-s symfile] [-e prog] [-se prog] [-c core] [-x cmds] [-d dir] [prog[core|procID]] 常用的操作：1234567891011121314151617gdb [可执行文件]：选中可执行程序,进入gdb的debug模式； (gdb) b（breakpoint）:用法：b 函数名 ：对此函数进行中断 ；b 文件名：行号； (gdb) run：启动程序，运行至程序的断点或者结束； (gdb) l(list):用法：l funcname，制定函数的源码。或者l linenum，显示指定行周围的源码。或l -，显示当前行前面的源码。或l，显示当前行后面的源码； (gdb) s(step):进入函数，逐语句运行； (gdb) n(next):不进入函数，逐过程运行； (gdb) c（continue）：继续运行，跳至下一个断点； (gdb) p（print）：打印显示变量值； (gdb) set variable=value,为变量赋值； (gdb) kill：终止调试的程序； (gdb) h（help）：列出gdb详细命令帮助列表； (gdb) clear filename.c:30：清除30行处的断点； (gdb) info break：显示断点信息； (gdb) delete 断点编号：断点编号是info break 后显示出来的； (gdb) bt（backtrace）：回溯到段出错的位置； (gdb) frame 帧号：帧号是bt命令产生的堆栈针； (gdb) q：退出； gdb分屏操作（1）gdb模式下使用layout src 或者大于号 &gt;1layout src （2）还可以在进入gdb时加入参数-tui达到同样效果。 1gdb -tui (3)退出分屏模式1使用快捷键Ctrl+x+a切换。 Text User Interface(TUI)感兴趣的可以自己去了解，此处不展开]]></content>
      <categories>
        <category>计算机♂操作</category>
      </categories>
      <tags>
        <tag>GCC&amp;&amp;GDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础汇编语言]]></title>
    <url>%2F2018%2F12%2F06%2F%E5%9F%BA%E7%A1%80%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[CSAPP真的是一本神书，怕自己忘记，所以本博客大量截图书中原文一、数据格式 二、x86-64的CPU包含一组16个存储64位值的通用目的寄存器，用来存储整数数据和指针。 三、访问信息，x86-64的CPU支持多种操作数格式，各种不同操作数可能性被分为三种类型，分为立即数，用来表示常数；寄存器，用来表示某个寄存器的内容；内存引用，根据计算出来的地址访问某个内存位置。 四、MOV类(ps:最后两个数据传送操作可以将数据压入程序栈中，以及从程序栈中弹出数据。) 五、整数和逻辑操作（ps:加载有效地址指令leaq实际上是movq指令的变形。它的指令形式是从内存读数据到寄存器，但实际上并没有引用内存。） 六、mov和lea指令的区别 LEA表示负载有效地址 MOV平均负荷值 简而言之，LEA加载指向你要寻址的项的指针，而MOV则在该地址加载实际值。例如:123mov ecx,[eax+0x30]表示先运算eax+0x30得到一个结果,以这个结果为地址找一个ecx长度的内存数赋给ecxlea ecx,[eax+0x30]表示先运算eax+0x30得到一个结果,把这个结果(mov时地址)赋给ecx效果为ecx=eax+0x30 (这里eax参与了运算却没有改变值) 七、条件控制跳转指令分三类： 无条件跳转: JMP; 根据 CX、ECX 寄存器的值跳转: JCXZ(CX 为 0 则跳转)、JECXZ(ECX 为 0 则跳转); 根据 EFLAGS 寄存器的标志位跳转, 以下罗列. 根据标志位跳转的指令：123456789101112131415161718192021222324252627282930313233343536373839JE ;等于则跳转JNE ;不等于则跳转JZ ;为 0 则跳转JNZ ;不为 0 则跳转JS ;为负则跳转JNS ;不为负则跳转JC ;进位则跳转JNC ;不进位则跳转JO ;溢出则跳转JNO ;不溢出则跳转JA ;无符号大于则跳转JNA ;无符号不大于则跳转JAE ;无符号大于等于则跳转JNAE ;无符号不大于等于则跳转JG ;有符号大于则跳转JNG ;有符号不大于则跳转JGE ;有符号大于等于则跳转JNGE ;有符号不大于等于则跳转JB ;无符号小于则跳转JNB ;无符号不小于则跳转JBE ;无符号小于等于则跳转JNBE ;无符号不小于等于则跳转JL ;有符号小于则跳转JNL ;有符号不小于则跳转JLE ;有符号小于等于则跳转JNLE ;有符号不小于等于则跳转JP ;奇偶位置位则跳转JNP ;奇偶位清除则跳转JPE ;奇偶位相等则跳转JPO ;奇偶位不等则跳转 跳转相关的标志位: 11 10 9 8 7 6 5 4 3 2 1 0 OF DF IF TF SF ZF AF PF CF 溢出 DF IF TF 符号 零 辅助 奇偶 进位 八、特殊算术]]></content>
      <categories>
        <category>计算机通识课笔记</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSAPP又双叒叕来一遍之程序的机器级表示]]></title>
    <url>%2F2018%2F12%2F06%2FCSAPP%E5%8F%88%E5%8F%8C%E5%8F%92%E5%8F%95%E6%9D%A5%E4%B8%80%E9%81%8D%E4%B9%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[一、本章主要内容 二、程序编码计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。对于机器级编程来说，其中两种抽象尤为重要： 指令集体系结构或指令级框架：它定义了处理器状态、指令的格式，以及每条指令对状态的影响。IA32将程序的行为描述成好像每条指令时按顺序执行的，一条指令结束后，下一条再开始。（实际上处理器并发地执行许多指令，但是可以采取措施保证整体行为与ISA指定的顺序执行完全一致） 机器级程序使用的存储器地址是虚拟地址：提供的存储器模型看上去是一个非常大的字节数组。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。 程序存储器(program memory)包含： 程序的可执行机器代码、操作系统需要的一些信息、栈、堆。程序存储器用虚拟地址来寻址（此虚拟地址不是机器级虚拟地址）。操作系统负责管理虚拟地址空间（程序级虚拟地址），将虚拟地址翻译成实际处理器存储器中的物理地址（机器级虚拟地址）。 三、拿一个C自己玩玩 用c语言写一个代码文件hello.c 在命令行上使用“-S”选项，就能看到C语言编译器产生的汇编代码 1Linux&gt; gcc -Og -S hello.c 编译为可执行文件 1Linux&gt; gcc -o hello hello.c 看机器代码文件的内容，有一类称为反汇编器，带“-d”命令行 1linux&gt; objdump -d hello (ps：汇编指令单独写博客，本地不展开) 四、 过程 过程是软件中一种很重要的抽象。它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现某种功能。然后，可以在程序中不同的地方调用这个函数。过程机制的构建需要实现传递控制、传递数据、分配和释放内存。 当x86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个部分称为过程的栈帧。 （栈在过程中的变化单独细讲，本处不展开） 五、异质的数据结构Struct 和 Union有下列区别： 在存储多个成员信息时，编译器会自动给struct第1个成员分配存储空间，struct 可以存储多个成员信息，而Union每个成员会用同一个存储空间，只能存储最后一个成员的信息。 都是由多个不同的数据类型成员组成，但在任何同一时刻，Union只存放了一个被先选中的成员，而结构体的所有成员都存在。 对于Union的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了，而对于struct 的不同成员赋值 是互不影响的。 六、对抗缓冲区溢出攻击1、栈随机化（ASLR和PIE）为了在系统中插入攻击代码，攻击者不但要插入代码，还要插入指向这段代码的指针，这个指针也是攻击字符串的一部分。产生这个指针需要知道这个字符串放置的栈地址。在过去，程序的栈地址非常容易预测，在不同的机器之间，栈的位置是相当固定的。栈随机化的思想使得栈的位置在程序每次运行时都有变化。因此，即使许多机器都运行相同的代码。它们的栈地址都是不同的。实现的方式是：程序开始时，在栈上分配一段0–n字节之间的随机大小空间。程序不使用这段空间，但是它会导致程序每次执行时后续的栈位置发生了变化。在Linux系统中，栈随机化已经变成了标准行为。（在linux上每次运行相同的程序，其同一局部变量的地址都不相同） 2、栈破坏检测在C语言中，没有可靠的方法来防止对数组的越界写，但是，我们能够在发生了越界写的时候，在没有造成任何有害结果之前，尝试检测到它。最近的GCC版本在产生的代码中加入了一种栈保护者机制，用来检测缓冲区越界，其思想是在栈中任何局部缓冲区与栈状态之间存储一个特殊的金丝雀值。这个金丝雀值是在程序每次运行时随机产生的，因此，攻击者没有简单的办法知道它是什么。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者函数调用的某个操作改变了。如果是，那么程序异常终止。 3、限制可执行代码区域限制那些能够存放可执行代码的存储器区域。在典型的程序中，只有保存编译器产生的代码的那部分存储器才需要是可执行的，其他部分可以被限制为只允许读和写。现在的64位处理器的内存保护引入了”NX”(不执行)位。有了这个特性，栈可以被标记为可读和可写，但是不可执行，检查页是否可执行由硬件来完成，效率上没有损失。]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSAPP又双叒叕来一遍之计算机系统漫游]]></title>
    <url>%2F2018%2F12%2F03%2FCSAPP%E5%8F%88%E5%8F%8C%E5%8F%92%E5%8F%95%E6%9D%A5%E4%B8%80%E9%81%8D%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8%2F</url>
    <content type="text"><![CDATA[说在前面的一些废话，如果你困了，请直接跳至正文刚入学就买的这本《深入理解计算机系统》。一年多来，学学停停，但是永远记住了第一章第二段的第二句话12如果你全力投身学习本书的概念，完全理解底层计算机系统以及它对应用程序的影响那么你会走向为数不多的“大牛”的道路 好一个大牛的道路，对于热爱计算机的人来说的“大牛的道路” 和 爱好钱财的人的“富婆包养路”（或者是富萝莉）地位相同在这句话的驱动下（多少人和我一样啊），这本书是我花费最多时间和精力去啃的专业书籍这本书确实无敌到能让一个完全不懂的孩童般见识到了计算机专业广阔无垠、波澜壮阔的海洋。惭愧的是完全没有达到大牛们啃完后通彻计算机系统的境界即便是如此我还是受益匪浅，CSAPP无愧为计算机专业的神书！如今我已经大二，按理说是踌躇满志的时候，我却满是遗憾，遗憾自己大一后半学期的固步自封，浪费了那么多宝贵的青春年华在毫无意义的事物上，追求短暂的愉悦却荒芜了年华。 但是往昔不可忆，切记不要再浪费自己的青春和元气。所以重整旗鼓，这回想认真总结一下（感言结束，疯狂暗示+安利）一、分析hello.c的例子，从其生命周期分析系统的执行过程hello.c 源代码：123456#include&lt;stdio.h&gt;int main()&#123; printf(&quot;hello world&quot;); return 0;&#125; 在Unix系统上,从源文件到目标文件的转化是由编译器驱动程序完成的:1unix&gt;gcc -o hello hello.c 执行这四个阶段的程序(预处理器、编译器、汇编器、链接器)一起构成了编译系统(compilation system). 预处理阶段:也就是对程序进行预处理。C程序中特指“”#“”包含的库文件。预处理器将库文件直接导入到源代码中，此例就是将头文件“stdio.h”导入到源程序中，生成hello.i源代码。 编译阶段:编译器(ccl)将文本文件hello.i翻译成文本文件hello.s,它包含一个汇编语言程序. 汇编阶段: 将汇编语言转化为机器指令,生成二进制文件——hello.o。 链接阶段.目标文件合并到我们的hello.o程序中,链接器就处理这种合并.得到hello文件,一个可执行目标文件,可以被加载到内存中,由系统执行. 二、信息就是位+上下文源程序实际上就是由一个值0和1组成的位(bit)序列,8个位被组织成一组,称为字节.每个字节表示程序中某个文本字符.大部分现代系统都是有ASCII标准表示文本字符,只由ASCII字符构成的文件称为文本文件,所有其他文件都称为二进制文件系统中所有的信息—–包括磁盘文件、存储器中的程序、存储器中存放的用户数据以及网络上传送的数据,都是由一串位表示的.区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文.比如:在不同的上下文中,一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令. 三、系统的硬件组成CPU:中央处理单元 &ensp; ALU:算术/逻辑单元 &ensp;PC:程序计数器 &ensp;USB:通用串行总线 总线贯穿整个系统的是一组电子管道,称做总线,它携带信息字节并负责在各个部件间传递. I/O设备:输入/输出(I/O)设备是系统与外部世界的联系通道 主存:主存是一个临时存储设备,在处理器执行程序时,用来存放程序和程序处理的数据. 处理器:中央处理单元(CPU),简称处理器,是解释(或执行)存储在主存中指令的引擎.处理器的核心是一个字长的存储设备(或寄存器),称为程序计数器(PC). 四、存储设备形成层次结构存储器层次结构的主要思想是一层上的存储器作为低一层存储器的高速缓存. 五、线程进程，单独分离写了个博客，这里不重复六、计算机系统中抽象的重要性 文件是对I/O的抽象 虚拟存储器是对程序存储器的抽象. 进程是对一个正在运行的程序的抽象. 虚拟机,它提供对整个计算机(操作系统,处理器和程序)的抽象. 七、虚拟内存虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。在linux中，进程的虚拟地址空间如下图 程序代码和数据：对于所有进程来说，代码从一固定地址开始，紧接和C全局变量相对应的数据位置。第七章研究链接和加载时，学到更多有关地址空间的内容。 堆 ：代码和数据区紧随着运行时堆。代码和数据区是在进程一开始就被规定了大小，与此不同，调用malloc和free时堆动态的扩展和收缩。第9章学习管理虚拟存储器时，详细研究。 共享库：地址空间的中间部分存放C标准库和数学库这样共享库代码和数据的区域。共享库概念非常强大，相当难懂。第七章详解。 栈: 用户虚拟地址顶部的是用户栈，编译器用它来实现函数调用。和堆一样，在执行时动态的扩展和收缩。第三章详解。 内核虚拟内存。 内核总是驻留在内存中，是操作系统一部分。 总结：由于本章只是计算机漫游，故只阐释了计算机的大概，具体细节后面章节，慢慢展开]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[多线程和多进程的暧昧缠绵]]></title>
    <url>%2F2018%2F12%2F03%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%9A%A7%E6%98%A7%E7%BC%A0%E7%BB%B5%2F</url>
    <content type="text"><![CDATA[先教科书一波（“千万别被吓到”），教科书上关于多进程和多线程解释为1进程是资源分配的最小单位，线程是CPU调度的最小单位 据说这句话拿去考试,改卷老师一定会给高分，但是还是嘚深入了解一下 线程的定义：1234线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。一个线程是一个execution context（执行上下文）即一个cpu执行时所需要的一串指令。 线程的工作方式类比：1234567假设你正在读一本书，没有读完，你想休息一下，但是你想在回来时恢复到当时读的具体进度。有一个方法就是记下页数、行数与字数这三个数值，这些数值就是execution context。如果你的室友在你休息的时候，使用相同的方法读这本书。你和她只需要这三个数字记下来就可以在交替的时间共同阅读这本书了。线程的工作方式与此类似。CPU会给你一个在同一时间能够做多个运算的幻觉，实际上它在每个运算上只花了极少的时间，本质上CPU同一时刻只干了一件事。它能这样做就是因为它有每个运算的execution context。就像你能够和你朋友共享同一本书一样，多任务也能共享同一块CPU。 进程的定义：1234一个程序的执行实例就是一个进程。每一个进程提供执行程序所需的所有资源。（进程本质上是资源的集合）一个进程有一个虚拟的地址空间、可执行的代码、操作系统的接口、安全的上下文（记录启动该进程的用户和权限等等）唯一的进程ID、环境变量、优先级类、最小和最大的工作空间（内存空间），还要有至少一个线程。每一个进程启动时都会最先产生一个线程，即主线程。然后主线程会再创建其他的子线程。 文邹邹的讲一下区别（如果你困了，请直接跳至图解进程线程） 同一个进程中的线程共享同一内存空间，但是进程之间是独立的。 同一个进程中的所有线程的数据是共享的（进程通讯），进程之间的数据是独立的。 对主线程的修改可能会影响其他线程的行为，但是父进程的修改（除了删除以外）不会影响其他子进程。 线程是一个上下文的执行指令，而进程则是与运算相关的一簇资源。 同一个进程的线程之间可以直接通信，但是进程之间的交流需要借助中间代理来实现。 创建新的线程很容易，但是创建新的进程需要对父进程做一次复制。 一个线程可以操作同一进程的其他线程，但是进程只能操作其子进程。 线程启动速度快，进程启动速度慢（但是两者运行速度没有可比性）。再配上一张图来对比一下有趣的图解一波程序执行的线程与进程的概念 计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。 假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。 进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程其他进程处于非运行状态. 一个车间里，可以有很多工人。他们协同完成一个任务。 线程就好比车间里的工人。一个进程可以包括多个线程。 车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。 可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存 一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队等锁打开再进去。这就叫”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。 还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。 这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做”信号量”（Semaphore）用来保证多个线程不会互相冲突。不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。]]></content>
      <categories>
        <category>计算机通识课笔记</category>
      </categories>
      <tags>
        <tag>进程&amp;&amp;线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摸鱼儿·雁丘词]]></title>
    <url>%2F2018%2F11%2F27%2F%E6%91%B8%E9%B1%BC%E5%84%BF%C2%B7%E9%9B%81%E4%B8%98%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[雁丘是我QQ用了近7年的网名，我可能应该也是一个怀旧的人会一直用下去，也想和大家分享这首词。 12345678问世间，情为何物？直教生死相许。天南地北双飞客，老翅几回寒暑。欢乐趣，离别苦，就中更有痴儿女。君应有语，渺万里层云，千山暮雪，只影向谁去？横汾路，寂寞当年箫鼓。荒烟依旧平楚。招魂楚些何嗟及，山鬼暗啼风雨。天也妒，未信与，莺儿燕子俱黄土。千秋万古，为留待骚人，狂歌痛饮，来访雁丘处。 第一次读的时候大概是初一，那一年什么都还不懂，唯一留下的记忆就是被这首词惊艳到大概故事梗概为：1234567太和五年，作者去并州参加科举考试。因为出身名门，所以他自小一直受到良好的教育，很早便显露出文学才华。8岁时，因做诗而获得“神童”的美誉。虽然文采出众，但是官运艰涩，多次参加科举也未中选。这次他再一次参加科考，在赴试中遇到一个猎人。这个猎人将一对在天空翱翔的大雁射下一只，另一只在空中盘旋哀鸣，确信伴侣已死，便也头朝地死。大雁的情谊深深打动了作者，于是便有了这首词。作者从猎人手中把一双大雁买下，葬在这个当年箫鼓声声的横汾路，为其坟墓取名“雁丘”。 后来多年，这首词总是跟随着我，仿佛一个可爱的玩具。]]></content>
      <categories>
        <category>万物可爱，世间温柔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[win10如何在任意文件下打开admin的cmd]]></title>
    <url>%2F2018%2F11%2F26%2Fwin10%E5%A6%82%E4%BD%95%E5%9C%A8%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E6%89%93%E5%BC%80admin%E7%9A%84cmd%2F</url>
    <content type="text"><![CDATA[win10 的win+cmd 打开控制台你要在跳到某文件夹下要多次的cd cd cd cd一次偶然机会发现可以修改一点点注册表即可实现任意文件下打开终端 第一步：新建任意文本文件复制下列代码1234567891011121314151617Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\Directory\shell\runas]@=&quot;Open cmd here as Admin&quot;&quot;HasLUAShield&quot;=&quot;&quot;[HKEY_CLASSES_ROOT\Directory\shell\runas\command]@=&quot;cmd.exe /s /k pushd \&quot;%V\&quot;&quot;[-HKEY_CLASSES_ROOT\Directory\Background\shell\runas][HKEY_CLASSES_ROOT\Directory\Background\shell\runas]@=&quot;Open cmd here as Admin&quot;&quot;HasLUAShield&quot;=&quot;&quot;[HKEY_CLASSES_ROOT\Directory\Background\shell\runas\command]@=&quot;cmd.exe /s /k pushd \&quot;%V\&quot;&quot;[-HKEY_CLASSES_ROOT\Drive\shell\runas][HKEY_CLASSES_ROOT\Drive\shell\runas]@=&quot;Open cmd here as Admin&quot;&quot;HasLUAShield&quot;=&quot;&quot;[HKEY_CLASSES_ROOT\Drive\shell\runas\command] 第二步：修改文件后缀名为.reg(例如 cmd.reg) 第三步：双击有个安全询问弹窗，点击确定即可。 测试：在任意文件夹下，右键有一个“Open cmd here as Admin”（字母能自定义）]]></content>
      <categories>
        <category>计算机♂操作</category>
      </categories>
  </entry>
</search>
